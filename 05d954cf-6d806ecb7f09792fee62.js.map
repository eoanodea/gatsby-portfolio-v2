{"version":3,"sources":["webpack:///./node_modules/framer-motion/dist/framer-motion.es.js"],"names":["isRefObject","ref","hasOwnProperty","MotionValue","init","value","_this","this","timeDelta","lastUpdated","canTrackVelocity","updateAndNotify","v","render","prev","current","updateSubscribers","forEach","notifySubscriber","renderSubscribers","_a","delta","timestamp","postRender","scheduleVelocityCheck","subscriber","velocityCheck","set","isNaN","parseFloat","prototype","subscribeTo","subscriptions","subscription","updateSubscriber","add","delete","onChange","Set","clearListeners","clear","onRenderRequest","attach","passiveEffect","get","getPrevious","getVelocity","start","animation","stop","Promise","resolve","stopAnimation","then","clearAnimation","isAnimating","destroy","motionValue","VisualElement","parent","children","latest","values","Map","valueSubscriptions","config","update","onUpdate","triggerRender","scheduleRender","element","mount","unmount","externalRef","treePath","depth","subscribe","child","hasValue","key","has","addValue","removeValue","subscribeToValue","unsubscribe","getValue","defaultValue","undefined","forEachValue","callback","getInstance","updateConfig","setSingleStaticValue","setStaticValues","unsubscribeOnChange","unsubscribeOnRender","removeFromParent","_","noop","any","convertBoundingBoxToAxisBox","top","x","min","left","max","right","y","bottom","copyAxisBox","box","zeroDelta","translate","scale","origin","originPoint","int","transform","Math","round","defaultValueTypes","color","backgroundColor","outlineColor","fill","stroke","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","borderWidth","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","borderRadius","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","width","maxWidth","height","maxHeight","size","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","margin","marginTop","marginRight","marginBottom","marginLeft","rotate","rotateX","rotateY","rotateZ","scaleX","scaleY","scaleZ","skew","skewX","skewY","distance","translateX","translateY","translateZ","z","perspective","opacity","originX","originY","originZ","zIndex","fillOpacity","strokeOpacity","numOctaves","dimensionValueTypes","test","parse","testValueType","type","findDimensionValueType","find","valueTypes","findValueType","getDefaultValueType","getValueAsType","axes","transformProps","sortTransformProps","a","b","indexOf","operationKey","axesKey","push","transformPropSet","isTransformProp","transformOriginProps","isTransformOriginProp","translateAlias","isCSSVariable","startsWith","pixelsToPercent","pixels","axis","borderCorrectionDefinition","process","viewportBox","valueScaleCorrection","applyTo","boxShadow","_viewportBox","treeScale","shadow","template","createTransformer","xScale","yScale","averageScale","buildHTMLStyles","style","vars","transformOrigin","transformKeys","isLayoutProjectionEnabled","deltaFinal","targetBox","enableHardwareAcceleration","transformTemplate","allowTransformNone","length","hasTransform","hasTransformOrigin","transformIsNone","valueType","valueAsType","default","bucket","corrected","num","i","layoutReprojection","transformIsDefault","transformString","transformHasZ","sort","numTransformKeys","trim","buildTransform","resetAxis","originAxis","scalePoint","point","applyPointDelta","boxScale","applyAxisDelta","applyBoxDelta","applyAxisTransforms","final","transforms","scaleKey","originKey","xKeys","yKeys","removePointDelta","removeAxisTransforms","removeAxisDelta","clampProgress","isNear","target","maxDistance","calcOrigin","source","sourceLength","targetLength","updateAxisDelta","sourcePoint","calcTranslate","updateBoxDelta","eachAxis","handler","isKeyframesTarget","Array","isArray","underDampedSpring","stiffness","damping","restDelta","restSpeed","overDampedSpring","to","linearTween","ease","duration","keyframes","defaultTransitions","just","complete","easingDefinitionToFunction","definition","x1","y1","x2","y2","isEasingArray","isAnimatable","secondsToMilliseconds","seconds","transitions","tween","spring","inertia","transitionOptionParser","opts","from","velocity","easings","map","getTransitionDefinition","transitionDefinition","delay","when","delayChildren","staggerChildren","staggerDirection","transition","Object","keys","isTransitionDefined","valueKey","transitionFactory","getDefaultTransition","valueTransitionDefinition","getAnimation","isOriginAnimatable","isTargetAnimatable","_b","actionFactory","preprocessOptions","repeatDelay","startAnimation","delay$1","activeAnimation","animationFactory","valueDelay","options","animate","getBoundingBox","transformPagePoint","transformPoint","topLeft","bottomRight","transformBoundingBox","getBoundingClientRect","HTMLVisualElement","_super","apply","arguments","defaultConfig","reactStyle","hasLayoutChildren","layoutUpdateListeners","hasViewportBoxUpdated","targetBoxFinal","stopLayoutAxisAnimation","isTargetBoxLocked","axisProgress","call","clean","read","getComputedStyle","readNativeValue","defaultValueType","enableLayoutProjection","forEachParent","hide","isVisible","show","onLayoutUpdate","layoutReady","listener","prevViewportBox","getBoundingBoxWithoutTransforms","bbox","window","snapshotBoundingBox","measureLayout","boxCorrected","refreshTargetBox","lockTargetBox","unlockTargetBox","stopLayoutAnimation","resetTransform","setAxisTarget","targetAxis","scheduleChildrenLayoutRender","startLayoutAxisAnimation","progress","updateLayoutDeltas","isReactRender","originBox","p","treeLength","applyTreeDeltas","finalBox","applyBoxTransforms","onViewportBoxUpdate","build","visibility","assign","setProperty","useConstant","calcOrigin$1","offset","progressToPixels","dashKeys","array","camelKeys","unmeasured","buildSVGAttrs","attrs","dimensions","totalPathLength","attrX","attrY","pathLength","pathSpacing","_c","pathOffset","calcSVGTransformOrigin","totalLength","spacing","useDashCase","buildSVGPath","camelCaseAttributes","CAMEL_CASE_PATTERN","camelToDash","str","replace","toLowerCase","SVGVisualElement","measure","getBBox","e","tagName","getTotalLength","getAttribute","setAttribute","svgTagNames","isSVGComponent","Component","PresenceContext","usePresence","context","isPresent","onExitComplete","register","id","useUniqueId","counter","incrementId","validMotionProps","isValidMotionProp","isPropValid","emotionIsPropValid_1","isCSSVariable$1","cssVariableRegex","getVariableValue","match","exec","parseCSSVariable","token","fallback","resolved","getPropertyValue","BoundingBoxDimension","positionalKeys","isPositionalKey","setAndResetVelocity","isNumOrPxType","getPosFromMatrix","matrix","pos","split","getTranslateFromMatrix","pos2","pos3","_bbox","matrix3d","nonTranslationalTransformKeys","filter","positionalValues","checkAndConvertChangedValueTypes","visualElement","transitionEnd","targetPositionalKeys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","toType","fromType","numKeyframes","removedTransforms","removeNonTranslationalTransform","convertedTarget","changedKeys","originBbox","elementComputedStyle","display","originComputedStyle","targetBbox","convertChangedValueTypes","unitConversion","some","hasPositionalKey","AnimationControls","hasMounted","pendingAnimations","componentControls","setVariants","variants","controls","setDefaultTransition","defaultTransition","transitionOverride","animations_1","all","MotionContext","static","isVariantLabel","isAnimationControls","useMotionContext","parentContext","isStatic","initialState","initial","whileTap","whileHover","layoutId","presenceContext","presenceId","isPresenceRoot","shouldPropagateControls","targetInitial","targetAnimate","initialDependency","animateDependency","isReducedMotion","isInitialOnly","isInitialRender","useInitialOrEveryRender","initialToApply","checkShouldInheritVariant","inherit","isMotionValue","addMotionValues","isStyle","foundMotionValue","reservedNames","empty","resolveFinalValueInKeyframes","VisualElementAnimationControls","makeTargetAnimatable","props","baseTarget","overrides","resolvedOverrides","activeOverrides","setProps","setValues","isActive","priority","_d","resolveVariant","transformValues","targetValue","checkForNewValues","newValueKeys","numNewValues","readValue","getAnimatableNone","variant","custom","getHighestPriority","setOverride","overrideIndex","startOverride","override","clearOverride","highest","resetIsAnimating","overrideTarget","remainingValues","onStart","onComplete","applyVariantLabels","variantLabelList","reverse","animateVariantLabels","animateVariant","animationDefinition","_e","getOriginFromTransition","getOrigin","animatable","animations","valueTarget","allAnimations","variantLabels","label","variantLabel","getAnimations","getChildrenAnimations","animateChildren","last","first","maxStaggerDuration","generateStaggerDuration","childControls","onAnimationStart","onAnimationComplete","checkOverrideIsAnimating","numOverrides","resolvedOverride","addChild","removeChild","resetChildren","useVisualElementAnimation","subscribeToParentControls","parentControls","unmountProps","MotionPluginContext","features","createLock","name","lock","globalHorizontalLock","globalVerticalLock","getGlobalLock","drag","openHorizontal_1","openVertical_1","isViewportScrollBlocked","document","addEventListener","event","preventDefault","passive","unblockViewportScroll","addDomEvent","eventName","removeEventListener","isMouseEvent","PointerEvent","pointerType","MouseEvent","isTouchEvent","touches","defaultPagePoint","pageX","pageY","pointFromTouch","pointType","changedTouches","pointFromMouse","extractEventInfo","getViewportPointFromEvent","Point","wrapHandler","shouldFilterPrimaryPointer","eventHandler","button","filterPrimaryPointer","isBrowser$1","mouseEventNames","pointerdown","pointermove","pointerup","pointercancel","pointerover","pointerout","pointerenter","pointerleave","touchEventNames","getPointerEventName","onpointerdown","ontouchstart","onmousedown","addPointerEvent","usePointerEvent","useDomEvent","subtract","relativeTo","idOrElem","elem","localElem","getElementById","rect","scrollX","scrollY","PanSession","handlers","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","onMove","initialInfo","onSessionStart","removeOnPointerMove","handlePointerMove","removeOnPointerUp","handlePointerUp","removeListeners","buttons","end","onEnd","panInfo","updateHandlers","lastDevicePoint","startDevicePoint","getVelocity$1","timestampedPoint","lastPoint","time","currentVelocity","Infinity","calcConstrainedMinPoint","constraints","elastic","applyConstraints","calcRelativeAxisConstraints","calcViewportAxisConstraints","layoutAxis","constraintsAxis","lastPointerEvent","elementDragControls","WeakMap","VisualElementDragControls","isDragging","currentDirection","cursorProgress","openGlobalLock","panSession","originEvent","snapToCursor","stopMotion","dragPropagation","prepareBoundingBox","resolveDragConstraints","onDragStart","dragDirectionLock","lockThreshold","direction","abs","getCurrentDirection","onDirectionLock","updateAxis","onDrag","dragConstraints","resolveRefConstraints","layoutBox","calcRelativeConstraints","onMeasureDragConstraints","constraintsElement","constraintsBox","measuredConstraints","calcViewportConstraints","userConstraints","convertAxisBoxToBoundingBox","cancelDrag","dragMomentum","dragElastic","onDragEnd","animateDragEnd","shouldDrag","axisLayout","axisLength","updateProps","_f","_g","remainingProps","dragTransition","momentumAnimations","bounceStiffness","bounceDamping","timeConstant","onDragTransitionEnd","boxProgress","calcPositionFromProgress","stopPointerListener","dragListener","stopResizeListener","stopLayoutUpdateListener","prevSnapshot","makeRenderlessComponent","hook","Drag","shouldRender","groupDragControls","dragControls","useDrag","useUnmountEffect","order$1","getGesturePriority","gesture","tapGesturePriority","hoverPriority","filterTouch","useGestures","onPan","onPanStart","onPanEnd","onPanSessionStart","hasPanEvents","usePanGesture","onTap","onTapStart","onTapCancel","hasTapListeners","isTapping","cancelPointerEventListener","removePointerUp","onPointerUp","openGestureLock","isNodeOrChild","parentElement","useTapGesture","onHoverStart","onHoverEnd","useHoverGesture","AnimatePropType","gestureProps","Gestures","Exit","exit","isPlayingExitAnimation","targetWithoutTransition","mergeTransitionEnd","resolveVariantLabels","unresolvedVariant","Presence","VisibilityAction","AnimatePropComponents","Target","targetAndTransition","prevValues","next","targetToAnimate","animatingTarget","finalTarget","shouldAnimateOnMount","isValidValue","valueHasUpdated","prevLength","shallowCompare","useAnimateProp","VariantLabel","targetVariants","parentAlreadyMounted","oldVariant","newVariant","shouldAnimate","join","useVariants","AnimationSubscription","useAnimationGroupSubscription","isAnimationSubscription","animationProps","animatePropTypeTests","prop","Animate","frameTarget","stopAxisAnimation","visibilityAction","layout","boxHasMoved","hasMoved","animateAxis","Hide","onLayoutAnimationComplete","presence","Present","safeToRemove","componentDidMount","unsubLayoutReady","componentWillUnmount","crossfadeOpacity","layoutProgress","crossfade","createCrossfadeAnimation","frame","tweenAxis","unsubscribeProgress","easeCrossfadeIn","easeCrossfadeOut","AnimateLayout","hasAxisMoved","compress","easing","defaultHandler","sortByDepth","createBatcher","queue","flush","order","isSharedLayout","forceUpdate","SharedLayoutContext","Measure","syncLayout","componentDidUpdate","getSnapshotBeforeUpdate","syncUpdate","defaultFeatures","createElement","useFeatures","shouldInheritVariant","plugins","allFeatures","numFeatures","Animation","animatePropType","getAnimationComponent","localContext","createMotionComponent","useVisualElement","animationControlsConfig","isTransform","existsAsProp","existsAsStyle","propIsMotionValue","styleIsMotionValue","useMotionValues","component","remove","useSnapshotOnUnmount","Provider","forwardedProps","domProps","filterProps","visualProps","buildSVGProps","htmlProps","userSelect","draggable","buildHTMLProps","HTMLElement","resolveCSSVariables","componentCache","motion","Proxy","createSwitchAnimation","stack","lead","Entering","prevLead","Show","getFollowOrigin","Exiting","getFollowTarget","stackLead","stackLeadPresence","follow","getLeadTransition","getLeadTarget","getLeadOrigin","LayoutStack","hasChildren","layoutOrder","index","findIndex","stackChild","splice","snapshot","boundingBox","latestMotionValues","updateLeadAndFollow","prevFollow","leadIndex","numInStack","lastIsPresent","findLeadAndFollow","updateSnapshot","isLeadPresent","shouldStackAnimate","AnimateSharedLayout","stacks","updateScheduled","renderScheduled","syncContext","force","scheduleUpdate","updateStacks","startLayoutAnimation","shouldComponentUpdate","createAnimation","getStack","addToStack","removeFromStack","createScrollMotionValues","scrollXProgress","scrollYProgress","useCycle","items","_i","item","setItem","prefersReducedMotion","matchMedia","motionMediaQuery_1","setReducedMotionPreferences","matches","addListener","DragControls","nativeEvent","StateVisualElement"],"mappings":"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","file":"05d954cf-6d806ecb7f09792fee62.js","sourcesContent":["import { __assign, __spreadArrays, __rest, __extends } from 'tslib';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nimport { velocityPerSecond, mix, clamp, distance, progress, linear as linear$1, circOut, interpolate, wrap } from '@popmotion/popcorn';\nimport { invariant, warning } from 'hey-listen';\nimport { number, color, complex, px, percent, degrees, vw, vh, scale, alpha, progressPercentage } from 'style-value-types';\nimport { action, delay, tween, spring, keyframes as keyframes$1, inertia } from 'popmotion';\nimport * as easingLookup from '@popmotion/easing';\nimport { cubicBezier, linear } from '@popmotion/easing';\nimport React__default, { useRef, createContext, useContext, useEffect, createElement, useMemo, Component, forwardRef, Fragment, useCallback, useState, cloneElement, Children, isValidElement, useLayoutEffect } from 'react';\n\nvar isRefObject = function isRefObject(ref) {\n  return typeof ref === \"object\" && ref.hasOwnProperty(\"current\");\n};\n\nvar isFloat = function isFloat(value) {\n  return !isNaN(parseFloat(value));\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\n\n\nvar MotionValue =\n/** @class */\nfunction () {\n  /**\n   * @param init - The initiating value\n   * @param config - Optional configuration options\n   *\n   * -  `transformer`: A function to transform incoming values with.\n   *\n   * @internal\n   */\n  function MotionValue(init) {\n    var _this = this;\n    /**\n     * Duration, in milliseconds, since last updating frame.\n     *\n     * @internal\n     */\n\n\n    this.timeDelta = 0;\n    /**\n     * Timestamp of the last time this `MotionValue` was updated.\n     *\n     * @internal\n     */\n\n    this.lastUpdated = 0;\n    /**\n     * Tracks whether this value can output a velocity. Currently this is only true\n     * if the value is numerical, but we might be able to widen the scope here and support\n     * other value types.\n     *\n     * @internal\n     */\n\n    this.canTrackVelocity = false;\n\n    this.updateAndNotify = function (v, render) {\n      if (render === void 0) {\n        render = true;\n      }\n\n      _this.prev = _this.current;\n      _this.current = v;\n\n      if (_this.updateSubscribers && _this.prev !== _this.current) {\n        _this.updateSubscribers.forEach(_this.notifySubscriber);\n      }\n\n      if (render && _this.renderSubscribers) {\n        _this.renderSubscribers.forEach(_this.notifySubscriber);\n      } // Update timestamp\n\n\n      var _a = getFrameData(),\n          delta = _a.delta,\n          timestamp = _a.timestamp;\n\n      if (_this.lastUpdated !== timestamp) {\n        _this.timeDelta = delta;\n        _this.lastUpdated = timestamp;\n        sync.postRender(_this.scheduleVelocityCheck);\n      }\n    };\n    /**\n     * Notify a subscriber with the latest value.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @param subscriber - The subscriber to notify.\n     *\n     * @internal\n     */\n\n\n    this.notifySubscriber = function (subscriber) {\n      subscriber(_this.current);\n    };\n    /**\n     * Schedule a velocity check for the next frame.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @internal\n     */\n\n\n    this.scheduleVelocityCheck = function () {\n      return sync.postRender(_this.velocityCheck);\n    };\n    /**\n     * Updates `prev` with `current` if the value hasn't been updated this frame.\n     * This ensures velocity calculations return `0`.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @internal\n     */\n\n\n    this.velocityCheck = function (_a) {\n      var timestamp = _a.timestamp;\n\n      if (timestamp !== _this.lastUpdated) {\n        _this.prev = _this.current;\n      }\n    };\n\n    this.set(init, false);\n    this.canTrackVelocity = isFloat(this.current);\n  }\n  /**\n   * Subscribes a subscriber function to a subscription list.\n   *\n   * @param subscriptions - A `Set` of subscribers.\n   * @param subscription - A subscriber function.\n   */\n\n\n  MotionValue.prototype.subscribeTo = function (subscriptions, subscription) {\n    var _this = this;\n\n    var updateSubscriber = function updateSubscriber() {\n      return subscription(_this.current);\n    };\n\n    subscriptions.add(updateSubscriber);\n    return function () {\n      return subscriptions.delete(updateSubscriber);\n    };\n  };\n  /**\n   * Adds a function that will be notified when the `MotionValue` is updated.\n   *\n   * It returns a function that, when called, will cancel the subscription.\n   *\n   * When calling `onChange` inside a React component, it should be wrapped with the\n   * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n   * from the `useEffect` function to ensure you don't add duplicate subscribers..\n   *\n   * @library\n   *\n   * ```jsx\n   * function MyComponent() {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.onChange(updateOpacity)\n   *     const unsubscribeY = y.onChange(updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <Frame x={x} />\n   * }\n   * ```\n   *\n   * @motion\n   *\n   * ```jsx\n   * export const MyComponent = () => {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.onChange(updateOpacity)\n   *     const unsubscribeY = y.onChange(updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <motion.div style={{ x }} />\n   * }\n   * ```\n   *\n   * @internalremarks\n   *\n   * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\n   *\n   * ```jsx\n   * useOnChange(x, () => {})\n   * ```\n   *\n   * @param subscriber - A function that receives the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.onChange = function (subscription) {\n    if (!this.updateSubscribers) this.updateSubscribers = new Set();\n    return this.subscribeTo(this.updateSubscribers, subscription);\n  };\n\n  MotionValue.prototype.clearListeners = function () {\n    var _a;\n\n    (_a = this.updateSubscribers) === null || _a === void 0 ? void 0 : _a.clear();\n  };\n  /**\n   * Adds a function that will be notified when the `MotionValue` requests a render.\n   *\n   * @param subscriber - A function that's provided the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @internal\n   */\n\n\n  MotionValue.prototype.onRenderRequest = function (subscription) {\n    if (!this.renderSubscribers) this.renderSubscribers = new Set(); // Render immediately\n\n    this.notifySubscriber(subscription);\n    return this.subscribeTo(this.renderSubscribers, subscription);\n  };\n  /**\n   * Attaches a passive effect to the `MotionValue`.\n   *\n   * @internal\n   */\n\n\n  MotionValue.prototype.attach = function (passiveEffect) {\n    this.passiveEffect = passiveEffect;\n  };\n  /**\n   * Sets the state of the `MotionValue`.\n   *\n   * @remarks\n   *\n   * ```jsx\n   * const x = useMotionValue(0)\n   * x.set(10)\n   * ```\n   *\n   * @param latest - Latest value to set.\n   * @param render - Whether to notify render subscribers. Defaults to `true`\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.set = function (v, render) {\n    if (render === void 0) {\n      render = true;\n    }\n\n    if (!render || !this.passiveEffect) {\n      this.updateAndNotify(v, render);\n    } else {\n      this.passiveEffect(v, this.updateAndNotify);\n    }\n  };\n  /**\n   * Returns the latest state of `MotionValue`\n   *\n   * @returns - The latest state of `MotionValue`\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.get = function () {\n    return this.current;\n  };\n  /**\n   * @public\n   */\n\n\n  MotionValue.prototype.getPrevious = function () {\n    return this.prev;\n  };\n  /**\n   * Returns the latest velocity of `MotionValue`\n   *\n   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.getVelocity = function () {\n    // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n    return this.canTrackVelocity ? // These casts could be avoided if parseFloat would be typed better\n    velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;\n  };\n  /**\n   * Registers a new animation to control this `MotionValue`. Only one\n   * animation can drive a `MotionValue` at one time.\n   *\n   * ```jsx\n   * value.start()\n   * ```\n   *\n   * @param animation - A function that starts the provided animation\n   *\n   * @internal\n   */\n\n\n  MotionValue.prototype.start = function (animation) {\n    var _this = this;\n\n    this.stop();\n    return new Promise(function (resolve) {\n      _this.stopAnimation = animation(resolve);\n    }).then(function () {\n      return _this.clearAnimation();\n    });\n  };\n  /**\n   * Stop the currently active animation.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.stop = function () {\n    if (this.stopAnimation) this.stopAnimation();\n    this.clearAnimation();\n  };\n  /**\n   * Returns `true` if this value is currently animating.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.isAnimating = function () {\n    return !!this.stopAnimation;\n  };\n\n  MotionValue.prototype.clearAnimation = function () {\n    this.stopAnimation = null;\n  };\n  /**\n   * Destroy and clean up subscribers to this `MotionValue`.\n   *\n   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n   * created a `MotionValue` via the `motionValue` function.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.destroy = function () {\n    this.updateSubscribers && this.updateSubscribers.clear();\n    this.renderSubscribers && this.renderSubscribers.clear();\n    this.stop();\n  };\n\n  return MotionValue;\n}();\n/**\n * @internal\n */\n\n\nfunction motionValue(init) {\n  return new MotionValue(init);\n}\n/**\n * VisualElement is an abstract class that provides a generic animation-optimised interface to the\n * underlying renderer.\n *\n * Currently many features interact directly with HTMLVisualElement/SVGVisualElement\n * but the idea is we can create, for instance, a ThreeVisualElement that extends\n * VisualElement and we can quickly offer all the same features.\n */\n\n\nvar VisualElement =\n/** @class */\nfunction () {\n  function VisualElement(parent, ref) {\n    var _this = this; // An iterable list of current children\n\n\n    this.children = new Set(); // The latest resolved MotionValues\n\n    this.latest = {}; // A map of MotionValues used to animate this element\n\n    this.values = new Map(); // Unsubscription callbacks for each MotionValue\n\n    this.valueSubscriptions = new Map(); // A configuration for this VisualElement, each derived class can extend this.\n\n    this.config = {}; // A pre-bound call to the user-provided `onUpdate` callback. This won't\n    // be called more than once per frame.\n\n    this.update = function () {\n      return _this.config.onUpdate(_this.latest);\n    }; // Pre-bound version of render\n\n\n    this.triggerRender = function () {\n      return _this.render();\n    };\n\n    this.scheduleRender = function () {\n      return sync.render(_this.triggerRender, false, true);\n    }; // This function gets passed to the rendered component's `ref` prop\n    // and is used to mount/unmount the VisualElement\n\n\n    this.ref = function (element) {\n      element ? _this.mount(element) : _this.unmount();\n      if (!_this.externalRef) return;\n\n      if (typeof _this.externalRef === \"function\") {\n        _this.externalRef(element);\n      } else if (isRefObject(_this.externalRef)) {\n        _this.externalRef.current = element;\n      }\n    }; // Create a relationship with the provided parent. When we come to replace\n    // the auto-animation stuff with VisualElement we might need to make this\n    // relationship two-way\n\n\n    this.parent = parent;\n    this.treePath = parent ? __spreadArrays(parent.treePath, [parent]) : []; // Calculate the depth of this node in the VisualElement graph\n\n    this.depth = parent ? parent.depth + 1 : 0; // A reference to any externally-defined React ref. This might live better\n    // outside the VisualElement and be handled in a hook.\n\n    this.externalRef = ref;\n  }\n\n  VisualElement.prototype.subscribe = function (child) {\n    var _this = this;\n\n    this.children.add(child);\n    return function () {\n      return _this.children.delete(child);\n    };\n  }; // Check whether this element has a MotionValue of the provided key\n\n\n  VisualElement.prototype.hasValue = function (key) {\n    return this.values.has(key);\n  }; // Add a MotionValue\n\n\n  VisualElement.prototype.addValue = function (key, value) {\n    if (this.hasValue(key)) this.removeValue(key);\n    this.values.set(key, value);\n    this.latest[key] = value.get();\n    if (this.element) this.subscribeToValue(key, value);\n  }; // Remove a MotionValue\n\n\n  VisualElement.prototype.removeValue = function (key) {\n    var unsubscribe = this.valueSubscriptions.get(key);\n    unsubscribe && unsubscribe();\n    this.values.delete(key);\n    delete this.latest[key];\n    this.valueSubscriptions.delete(key);\n  };\n\n  VisualElement.prototype.getValue = function (key, defaultValue) {\n    var value = this.values.get(key);\n\n    if (value === undefined && defaultValue !== undefined) {\n      value = new MotionValue(defaultValue);\n      this.addValue(key, value);\n    }\n\n    return value;\n  }; // Iterate over all MotionValues\n\n\n  VisualElement.prototype.forEachValue = function (callback) {\n    this.values.forEach(callback);\n  }; // Get the underlying rendered instance of this VisualElement. For instance in\n  // HTMLVisualElement this will be a HTMLElement.\n\n\n  VisualElement.prototype.getInstance = function () {\n    return this.element;\n  };\n\n  VisualElement.prototype.updateConfig = function (config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    this.config = __assign({}, config);\n  }; // Set a single `latest` value\n\n\n  VisualElement.prototype.setSingleStaticValue = function (key, value) {\n    this.latest[key] = value;\n  }; // Statically set values to `latest` without needing a MotionValue\n\n\n  VisualElement.prototype.setStaticValues = function (values, value) {\n    if (typeof values === \"string\") {\n      this.setSingleStaticValue(values, value);\n    } else {\n      for (var key in values) {\n        this.setSingleStaticValue(key, values[key]);\n      }\n    }\n  }; // Subscribe to changes in a MotionValue\n\n\n  VisualElement.prototype.subscribeToValue = function (key, value) {\n    var _this = this;\n\n    var onChange = function onChange(latest) {\n      _this.setSingleStaticValue(key, latest);\n\n      _this.latest[key] = latest;\n      _this.config.onUpdate && sync.update(_this.update, false, true);\n    };\n\n    var unsubscribeOnChange = value.onChange(onChange);\n    var unsubscribeOnRender = value.onRenderRequest(this.scheduleRender);\n    this.valueSubscriptions.set(key, function () {\n      unsubscribeOnChange();\n      unsubscribeOnRender();\n    });\n  }; // Mount the VisualElement with the actual DOM element\n\n\n  VisualElement.prototype.mount = function (element) {\n    var _this = this;\n\n    invariant(!!element, \"No ref found. Ensure components created with motion.custom forward refs using React.forwardRef\");\n\n    if (this.parent) {\n      this.removeFromParent = this.parent.subscribe(this);\n      /**\n       * Save a reference to the nearest layout projecting ancestor.\n       */\n      // this.layoutParent = this.parent.isLayoutProjectionEnabled\n      //     ? this.parent\n      //     : this.parent.layoutParent\n    }\n    /**\n     * Save the element to this.element as a semantic API, this.current to the VisualElement\n     * is compatible with existing RefObject APIs.\n     */\n\n\n    this.element = this.current = element; // Subscribe to any pre-existing MotionValues\n\n    this.forEachValue(function (value, key) {\n      return _this.subscribeToValue(key, value);\n    });\n  }; // Unmount the VisualElement and cancel any scheduled updates\n\n\n  VisualElement.prototype.unmount = function () {\n    var _this = this;\n\n    this.forEachValue(function (_, key) {\n      return _this.removeValue(key);\n    });\n    cancelSync.update(this.update);\n    cancelSync.render(this.render);\n    this.removeFromParent && this.removeFromParent();\n  };\n\n  return VisualElement;\n}();\n\nfunction noop(any) {\n  return any;\n}\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\n\n\nfunction convertBoundingBoxToAxisBox(_a) {\n  var top = _a.top,\n      left = _a.left,\n      right = _a.right,\n      bottom = _a.bottom;\n  return {\n    x: {\n      min: left,\n      max: right\n    },\n    y: {\n      min: top,\n      max: bottom\n    }\n  };\n}\n\nfunction convertAxisBoxToBoundingBox(_a) {\n  var x = _a.x,\n      y = _a.y;\n  return {\n    top: y.min,\n    bottom: y.max,\n    left: x.min,\n    right: x.max\n  };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\n\n\nfunction transformBoundingBox(_a, transformPoint) {\n  var top = _a.top,\n      left = _a.left,\n      bottom = _a.bottom,\n      right = _a.right;\n\n  if (transformPoint === void 0) {\n    transformPoint = noop;\n  }\n\n  var topLeft = transformPoint({\n    x: left,\n    y: top\n  });\n  var bottomRight = transformPoint({\n    x: right,\n    y: bottom\n  });\n  return {\n    top: topLeft.y,\n    left: topLeft.x,\n    bottom: bottomRight.y,\n    right: bottomRight.x\n  };\n}\n/**\n * Create an empty axis box of zero size\n */\n\n\nfunction axisBox() {\n  return {\n    x: {\n      min: 0,\n      max: 1\n    },\n    y: {\n      min: 0,\n      max: 1\n    }\n  };\n}\n\nfunction copyAxisBox(box) {\n  return {\n    x: __assign({}, box.x),\n    y: __assign({}, box.y)\n  };\n}\n/**\n * Create an empty box delta\n */\n\n\nvar zeroDelta = {\n  translate: 0,\n  scale: 1,\n  origin: 0,\n  originPoint: 0\n};\n\nfunction delta() {\n  return {\n    x: __assign({}, zeroDelta),\n    y: __assign({}, zeroDelta)\n  };\n}\n/**\n * ValueType for \"auto\"\n */\n\n\nvar auto = {\n  test: function test(v) {\n    return v === \"auto\";\n  },\n  parse: function parse(v) {\n    return v;\n  }\n};\n/**\n * ValueType for ints\n */\n\nvar int = __assign(__assign({}, number), {\n  transform: Math.round\n});\n/**\n * A map of default value types for common values\n */\n\n\nvar defaultValueTypes = {\n  // Color props\n  color: color,\n  backgroundColor: color,\n  outlineColor: color,\n  fill: color,\n  stroke: color,\n  // Border props\n  borderColor: color,\n  borderTopColor: color,\n  borderRightColor: color,\n  borderBottomColor: color,\n  borderLeftColor: color,\n  borderWidth: px,\n  borderTopWidth: px,\n  borderRightWidth: px,\n  borderBottomWidth: px,\n  borderLeftWidth: px,\n  borderRadius: px,\n  radius: px,\n  borderTopLeftRadius: px,\n  borderTopRightRadius: px,\n  borderBottomRightRadius: px,\n  borderBottomLeftRadius: px,\n  // Positioning props\n  width: px,\n  maxWidth: px,\n  height: px,\n  maxHeight: px,\n  size: px,\n  top: px,\n  right: px,\n  bottom: px,\n  left: px,\n  // Spacing props\n  padding: px,\n  paddingTop: px,\n  paddingRight: px,\n  paddingBottom: px,\n  paddingLeft: px,\n  margin: px,\n  marginTop: px,\n  marginRight: px,\n  marginBottom: px,\n  marginLeft: px,\n  // Transform props\n  rotate: degrees,\n  rotateX: degrees,\n  rotateY: degrees,\n  rotateZ: degrees,\n  scale: scale,\n  scaleX: scale,\n  scaleY: scale,\n  scaleZ: scale,\n  skew: degrees,\n  skewX: degrees,\n  skewY: degrees,\n  distance: px,\n  translateX: px,\n  translateY: px,\n  translateZ: px,\n  x: px,\n  y: px,\n  z: px,\n  perspective: px,\n  opacity: alpha,\n  originX: progressPercentage,\n  originY: progressPercentage,\n  originZ: px,\n  // Misc\n  zIndex: int,\n  // SVG\n  fillOpacity: alpha,\n  strokeOpacity: alpha,\n  numOctaves: int\n};\n/**\n * A list of value types commonly used for dimensions\n */\n\nvar dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\n * Tests a provided value against a ValueType\n */\n\nvar testValueType = function testValueType(v) {\n  return function (type) {\n    return type.test(v);\n  };\n};\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\n\n\nvar findDimensionValueType = function findDimensionValueType(v) {\n  return dimensionValueTypes.find(testValueType(v));\n};\n/**\n * A list of all ValueTypes\n */\n\n\nvar valueTypes = __spreadArrays(dimensionValueTypes, [color, complex]);\n/**\n * Tests a value against the list of ValueTypes\n */\n\n\nvar findValueType = function findValueType(v) {\n  return valueTypes.find(testValueType(v));\n};\n/**\n * Gets the default ValueType for the provided value key\n */\n\n\nvar getDefaultValueType = function getDefaultValueType(key) {\n  return defaultValueTypes[key];\n};\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\n\n\nvar getValueAsType = function getValueAsType(value, type) {\n  return type && typeof value === \"number\" ? type.transform(value) : value;\n};\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\n\n\nvar axes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\n\nvar order = [\"translate\", \"scale\", \"rotate\", \"skew\", \"transformPerspective\"];\n/**\n * Generate a list of every possible transform key.\n */\n\nvar transformProps = [\"x\", \"y\", \"z\"];\norder.forEach(function (operationKey) {\n  axes.forEach(function (axesKey) {\n    return transformProps.push(operationKey + axesKey);\n  });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\n\nfunction sortTransformProps(a, b) {\n  return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\n/**\n * A quick lookup for transform props.\n */\n\n\nvar transformPropSet = new Set(transformProps);\n\nfunction isTransformProp(key) {\n  return transformPropSet.has(key);\n}\n/**\n * A quick lookup for transform origin props\n */\n\n\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\n\nfunction isTransformOriginProp(key) {\n  return transformOriginProps.has(key);\n}\n\nvar translateAlias = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\"\n};\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\n\nfunction buildTransform(transform, transformKeys, transformTemplate, transformIsDefault, enableHardwareAcceleration, allowTransformNone) {\n  if (enableHardwareAcceleration === void 0) {\n    enableHardwareAcceleration = true;\n  }\n\n  if (allowTransformNone === void 0) {\n    allowTransformNone = true;\n  } // The transform string we're going to build into\n\n\n  var transformString = \"\"; // Track whether the defined transform has a defined z so we don't add a\n  // second to enable hardware acceleration\n\n  var transformHasZ = false; // Transform keys into their default order - this will determine the output order.\n\n  transformKeys.sort(sortTransformProps); // Loop over each transform and build them into transformString\n\n  var numTransformKeys = transformKeys.length;\n\n  for (var i = 0; i < numTransformKeys; i++) {\n    var key = transformKeys[i];\n    transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\n    if (key === \"z\") transformHasZ = true;\n  }\n\n  if (!transformHasZ && enableHardwareAcceleration) {\n    transformString += \"translateZ(0)\";\n  } else {\n    transformString = transformString.trim();\n  } // If we have a custom `transform` template, pass our transform values and\n  // generated transformString to that before returning\n\n\n  if (transformTemplate) {\n    transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n  } else if (allowTransformNone && transformIsDefault) {\n    transformString = \"none\";\n  }\n\n  return transformString;\n}\n/**\n * Returns true if the provided key is a CSS variable\n */\n\n\nfunction isCSSVariable(key) {\n  return key.startsWith(\"--\");\n}\n\nfunction pixelsToPercent(pixels, axis) {\n  return pixels / (axis.max - axis.min) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\n\n\nfunction correctBorderRadius(latest, viewportBox) {\n  /**\n   * If latest is a string, we either presume it's already a percentage, in which case it'll\n   * already be stretched appropriately, or it's another value type which we don't support.\n   */\n  if (typeof latest !== \"number\") return latest;\n  /**\n   * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n   * pixel value as a percentage of each axis\n   */\n\n  var x = pixelsToPercent(latest, viewportBox.x);\n  var y = pixelsToPercent(latest, viewportBox.y);\n  return x + \"% \" + y + \"%\";\n}\n\nfunction correctBoxShadow(latest, _viewportBox, delta, treeScale) {\n  // GC Warning - this creates a function and object every frame\n  var shadow = complex.parse(latest);\n  var template = complex.createTransformer(latest); // Calculate the overall context scale\n\n  var xScale = delta.x.scale * treeScale.x;\n  var yScale = delta.y.scale * treeScale.y; // Scale x/y\n\n  shadow[1] /= xScale;\n  shadow[2] /= yScale;\n  /**\n   * Ideally we'd correct x and y scales individually, but because blur and\n   * spread apply to both we have to take a scale average and apply that instead.\n   * We could potentially improve the outcome of this by incorporating the ratio between\n   * the two scales.\n   */\n\n  var averageScale = mix(xScale, yScale, 0.5); // Blur\n\n  if (typeof shadow[3] === \"number\") shadow[3] /= averageScale; // Spread\n\n  if (typeof shadow[4] === \"number\") shadow[4] /= averageScale;\n  return template(shadow);\n}\n\nvar borderCorrectionDefinition = {\n  process: correctBorderRadius\n};\nvar valueScaleCorrection = {\n  borderRadius: __assign(__assign({}, borderCorrectionDefinition), {\n    applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n  }),\n  borderTopLeftRadius: borderCorrectionDefinition,\n  borderTopRightRadius: borderCorrectionDefinition,\n  borderBottomLeftRadius: borderCorrectionDefinition,\n  borderBottomRightRadius: borderCorrectionDefinition,\n  boxShadow: {\n    process: correctBoxShadow\n  }\n};\n/**\n * @internal\n */\n\nfunction addScaleCorrection(correctors) {\n  for (var key in correctors) {\n    valueScaleCorrection[key] = correctors[key];\n  }\n}\n/**\n * Build style and CSS variables\n *\n * This function converts a Motion style prop:\n *\n * { x: 100, width: 100, originX: 0.5 }\n *\n * Into an object with default value types applied and default\n * transform order set:\n *\n * {\n *   transform: 'translateX(100px) translateZ(0)`,\n *   width: '100px',\n *   transformOrigin: '50% 50%'\n * }\n *\n * Styles are saved to `style` and CSS vars to `vars`.\n *\n * This function works with mutative data structures.\n */\n\n\nfunction buildHTMLStyles(latest, style, vars, transform, transformOrigin, transformKeys, _a, isLayoutProjectionEnabled, delta, deltaFinal, treeScale, targetBox) {\n  var enableHardwareAcceleration = _a.enableHardwareAcceleration,\n      transformTemplate = _a.transformTemplate,\n      allowTransformNone = _a.allowTransformNone; // Empty the transformKeys array. As we're throwing out refs to its items\n  // this might not be as cheap as suspected. Maybe using the array as a buffer\n  // with a manual incrementation would be better.\n\n  transformKeys.length = 0; // Track whether we encounter any transform or transformOrigin values.\n\n  var hasTransform = !!isLayoutProjectionEnabled;\n  var hasTransformOrigin = !!isLayoutProjectionEnabled; // Does the calculated transform essentially equal \"none\"?\n\n  var transformIsNone = true;\n  /**\n   * Loop over all our latest animated values and decide whether to handle them\n   * as a style or CSS variable. Transforms and transform origins are kept seperately\n   * for further processing\n   */\n\n  for (var key in latest) {\n    var value = latest[key]; // Convert the value to its default value type, ie 0 -> \"0px\"\n\n    var valueType = getDefaultValueType(key);\n    var valueAsType = getValueAsType(value, valueType);\n\n    if (isTransformProp(key)) {\n      // If this is a transform, flag and enable further transform processing\n      hasTransform = true;\n      transform[key] = valueAsType;\n      transformKeys.push(key);\n      if (!transformIsNone) continue; // If all the transform keys we've so far encountered are their default value\n      // then check to see if this one isn't\n\n      var defaultValue = valueType.default !== undefined ? valueType.default : 0;\n      if (value !== defaultValue) transformIsNone = false;\n    } else if (isTransformOriginProp(key)) {\n      // If this is a transform origin, flag and enable further transform-origin processing\n      transformOrigin[key] = valueAsType;\n      hasTransformOrigin = true;\n    } else if (key !== \"transform\" || typeof value !== \"function\") {\n      // Handle all remaining values. Decide which map to save to depending\n      // on whether this is a CSS variable\n      var bucket = isCSSVariable(key) ? vars : style; // If we need to perform scale correction, and we have a handler for this\n      // value type (ie borderRadius), perform it\n\n      if (isLayoutProjectionEnabled && valueScaleCorrection[key]) {\n        var corrected = valueScaleCorrection[key].process(value, targetBox, delta, treeScale);\n        /**\n         * Scale-correctable values can define a number of other values to break\n         * down into. For instance borderRadius needs applying to borderBottomLeftRadius etc\n         */\n\n        var applyTo = valueScaleCorrection[key].applyTo;\n\n        if (applyTo) {\n          var num = applyTo.length;\n\n          for (var i = 0; i < num; i++) {\n            bucket[applyTo[i]] = corrected;\n          }\n        } else {\n          bucket[key] = corrected;\n        }\n      } else {\n        bucket[key] = valueAsType;\n      }\n    }\n  } // Only process transform if values aren't defaults\n\n\n  if (hasTransform || transformTemplate) {\n    if (!isLayoutProjectionEnabled) {\n      style.transform = buildTransform(transform, transformKeys, transformTemplate, transformIsNone, enableHardwareAcceleration, allowTransformNone);\n    } else {\n      style.transform = layoutReprojection(deltaFinal, treeScale);\n    }\n  } // Only process transform origin if values aren't default\n\n\n  if (hasTransformOrigin) {\n    var originX = isLayoutProjectionEnabled ? deltaFinal.x.origin * 100 + \"%\" : transformOrigin.originX || \"50%\";\n    var originY = isLayoutProjectionEnabled ? deltaFinal.y.origin * 100 + \"%\" : transformOrigin.originY || \"50%\";\n    var originZ = transformOrigin.originZ || \"0\";\n    style.transformOrigin = originX + \" \" + originY + \" \" + originZ;\n  }\n}\n\nfunction layoutReprojection(delta, treeScale) {\n  var x = delta.x.translate / treeScale.x;\n  var y = delta.y.translate / treeScale.y;\n  var scaleX = delta.x.scale;\n  var scaleY = delta.y.scale;\n  return \"translate3d(\" + x + \"px, \" + y + \"px, 0) scale(\" + scaleX + \", \" + scaleY + \")\";\n}\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\n\n\nfunction resetAxis(axis, originAxis) {\n  axis.min = originAxis.min;\n  axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\n\n\nfunction resetBox(box, originBox) {\n  resetAxis(box.x, originBox.x);\n  resetAxis(box.y, originBox.y);\n}\n/**\n * Scales a point based on a factor and an originPoint\n */\n\n\nfunction scalePoint(point, scale, originPoint) {\n  var distanceFromOrigin = point - originPoint;\n  var scaled = scale * distanceFromOrigin;\n  return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\n\n\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n  if (boxScale !== undefined) {\n    point = scalePoint(point, boxScale, originPoint);\n  }\n\n  return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\n\n\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n\n  if (scale === void 0) {\n    scale = 1;\n  }\n\n  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\n\n\nfunction applyBoxDelta(box, _a) {\n  var x = _a.x,\n      y = _a.y;\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\n\n\nfunction applyAxisTransforms(final, axis, transforms, _a) {\n  var key = _a[0],\n      scaleKey = _a[1],\n      originKey = _a[2]; // Copy the current axis to the final axis before mutation\n\n  final.min = axis.min;\n  final.max = axis.max;\n  var originPoint = mix(axis.min, axis.max, transforms[originKey] || 0.5); // Apply the axis delta to the final axis\n\n  applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\n\n\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\n\nfunction applyBoxTransforms(finalBox, box, transforms) {\n  applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);\n  applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);\n}\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\n\n\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n  point -= translate;\n  point = scalePoint(point, 1 / scale, originPoint);\n\n  if (boxScale !== undefined) {\n    point = scalePoint(point, 1 / boxScale, originPoint);\n  }\n\n  return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\n\n\nfunction removeAxisDelta(axis, translate, scale, origin, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n\n  if (scale === void 0) {\n    scale = 1;\n  }\n\n  if (origin === void 0) {\n    origin = 0.5;\n  }\n\n  var originPoint = mix(axis.min, axis.max, origin) - translate;\n  axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\n\n\nfunction removeAxisTransforms(axis, transforms, _a) {\n  var key = _a[0],\n      scaleKey = _a[1],\n      originKey = _a[2];\n  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);\n}\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\n\n\nfunction removeBoxTransforms(box, transforms) {\n  removeAxisTransforms(box.x, transforms, xKeys);\n  removeAxisTransforms(box.y, transforms, yKeys);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n */\n\n\nfunction applyTreeDeltas(box, treeScale, treePath) {\n  treeScale.x = treeScale.y = 1;\n  var treeLength = treePath.length;\n\n  for (var i = 0; i < treeLength; i++) {\n    var parent_1 = treePath[i];\n    var delta = parent_1.delta;\n    applyBoxDelta(box, delta);\n    treeScale.x *= delta.x.scale;\n    treeScale.y *= delta.y.scale;\n  }\n}\n\nvar clampProgress = clamp(0, 1);\n/**\n * Returns true if the provided value is within maxDistance of the provided target\n */\n\nfunction isNear(value, target, maxDistance) {\n  if (target === void 0) {\n    target = 0;\n  }\n\n  if (maxDistance === void 0) {\n    maxDistance = 0.01;\n  }\n\n  return distance(value, target) < maxDistance;\n}\n/**\n * Calculate the translate needed to be applied to source to get target\n */\n\n\nfunction calcTranslate(source, target, origin) {\n  var sourcePoint = mix(source.min, source.max, origin);\n  var targetPoint = mix(target.min, target.max, origin);\n  return targetPoint - sourcePoint;\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\n\n\nfunction calcOrigin(source, target) {\n  var origin = 0.5;\n  var sourceLength = source.max - source.min;\n  var targetLength = target.max - target.min;\n\n  if (targetLength > sourceLength) {\n    origin = progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = progress(source.min, source.max - targetLength, target.min);\n  }\n\n  return clampProgress(origin);\n}\n/**\n * Update the AxisDelta with a transform that projects source into target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\n\n\nfunction updateAxisDelta(delta, source, target, origin) {\n  var sourceLength = source.max - source.min;\n  var targetLength = target.max - target.min;\n  delta.origin = origin === undefined ? calcOrigin(source, target) : origin;\n  delta.originPoint = mix(source.min, source.max, delta.origin);\n  delta.scale = targetLength / sourceLength;\n  if (isNear(delta.scale, 1, 0.0001)) delta.scale = 1;\n  delta.translate = calcTranslate(source, target, delta.origin);\n  if (isNear(delta.translate)) delta.translate = 0;\n}\n/**\n * Update the BoxDelta with a transform that projects the source into the target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\n\n\nfunction updateBoxDelta(delta, source, target, origin) {\n  updateAxisDelta(delta.x, source.x, target.x, origin);\n  updateAxisDelta(delta.y, source.y, target.y, origin);\n} // Call a handler once for each axis\n\n\nfunction eachAxis(handler) {\n  return [handler(\"x\"), handler(\"y\")];\n}\n\nvar isKeyframesTarget = function isKeyframesTarget(v) {\n  return Array.isArray(v);\n};\n\nvar underDampedSpring = function underDampedSpring() {\n  return {\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restDelta: 0.5,\n    restSpeed: 10\n  };\n};\n\nvar overDampedSpring = function overDampedSpring(to) {\n  return {\n    type: \"spring\",\n    stiffness: 700,\n    damping: to === 0 ? 100 : 35\n  };\n};\n\nvar linearTween = function linearTween() {\n  return {\n    ease: \"linear\",\n    duration: 0.3\n  };\n};\n\nvar keyframes = function keyframes(values) {\n  return {\n    type: \"keyframes\",\n    duration: 0.8,\n    values: values\n  };\n};\n\nvar defaultTransitions = {\n  x: underDampedSpring,\n  y: underDampedSpring,\n  z: underDampedSpring,\n  rotate: underDampedSpring,\n  rotateX: underDampedSpring,\n  rotateY: underDampedSpring,\n  rotateZ: underDampedSpring,\n  scaleX: overDampedSpring,\n  scaleY: overDampedSpring,\n  scale: overDampedSpring,\n  opacity: linearTween,\n  backgroundColor: linearTween,\n  color: linearTween,\n  default: overDampedSpring\n};\n\nvar getDefaultTransition = function getDefaultTransition(valueKey, to) {\n  var transitionFactory;\n\n  if (isKeyframesTarget(to)) {\n    transitionFactory = keyframes;\n  } else {\n    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;\n  }\n\n  return __assign({\n    to: to\n  }, transitionFactory(to));\n};\n/**\n * A Popmotion action that accepts a single `to` prop. When it starts, it immediately\n * updates with `to` and then completes. By using this we can compose instant transitions\n * in with the same logic that applies `delay` or returns a `Promise` etc.\n *\n * Accepting `duration` is a little bit of a hack that simply defers the completetion of\n * the animation until after the duration finishes. This is for situations when you're **only**\n * animating non-animatable values and then setting something on `transitionEnd`. Really\n * you want this to fire after the \"animation\" finishes, rather than instantly.\n *\n * ```\n * animate={{\n *   display: 'block',\n *   transitionEnd: { display: 'none' }\n * }}\n * ```\n */\n\n\nvar just = function just(_a) {\n  var to = _a.to,\n      duration = _a.duration;\n  return action(function (_a) {\n    var update = _a.update,\n        complete = _a.complete;\n    update(to);\n    duration ? delay(duration).start({\n      complete: complete\n    }) : complete();\n  });\n};\n\nvar easingDefinitionToFunction = function easingDefinitionToFunction(definition) {\n  if (Array.isArray(definition)) {\n    // If cubic bezier definition, create bezier curve\n    invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\n    var x1 = definition[0],\n        y1 = definition[1],\n        x2 = definition[2],\n        y2 = definition[3];\n    return cubicBezier(x1, y1, x2, y2);\n  } else if (typeof definition === \"string\") {\n    // Else lookup from table\n    invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\" + definition + \"'\");\n    return easingLookup[definition];\n  }\n\n  return definition;\n};\n\nvar isEasingArray = function isEasingArray(ease) {\n  return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\nvar isDurationAnimation = function isDurationAnimation(v) {\n  return v.hasOwnProperty(\"duration\") || v.hasOwnProperty(\"repeatDelay\");\n};\n/**\n * Check if a value is animatable. Examples:\n *\n * ✅: 100, \"100px\", \"#fff\"\n * ❌: \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\n\n\nvar isAnimatable = function isAnimatable(key, value) {\n  // If the list of keys tat might be non-animatable grows, replace with Set\n  if (key === \"zIndex\") return false; // If it's a number or a keyframes array, we can animate it. We might at some point\n  // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n  // but for now lets leave it like this for performance reasons\n\n  if (typeof value === \"number\" || Array.isArray(value)) return true;\n\n  if (typeof value === \"string\" && // It's animatable if we have a string\n  complex.test(value) && // And it contains numbers and/or colors\n  !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n  ) {\n      return true;\n    }\n\n  return false;\n};\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\n\n\nvar secondsToMilliseconds = function secondsToMilliseconds(seconds) {\n  return seconds * 1000;\n};\n\nvar transitions = {\n  tween: tween,\n  spring: spring,\n  keyframes: keyframes$1,\n  inertia: inertia,\n  just: just\n};\nvar transitionOptionParser = {\n  tween: function tween(opts) {\n    if (opts.ease) {\n      var ease = isEasingArray(opts.ease) ? opts.ease[0] : opts.ease;\n      opts.ease = easingDefinitionToFunction(ease);\n    }\n\n    return opts;\n  },\n  keyframes: function keyframes(_a) {\n    var from = _a.from,\n        to = _a.to,\n        velocity = _a.velocity,\n        opts = __rest(_a, [\"from\", \"to\", \"velocity\"]);\n\n    if (opts.values && opts.values[0] === null) {\n      var values = __spreadArrays(opts.values);\n\n      values[0] = from;\n      opts.values = values;\n    }\n\n    if (opts.ease) {\n      opts.easings = isEasingArray(opts.ease) ? opts.ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(opts.ease);\n    }\n\n    opts.ease = linear;\n    return opts;\n  }\n};\n\nvar isTransitionDefined = function isTransitionDefined(_a) {\n  var when = _a.when,\n      delay = _a.delay,\n      delayChildren = _a.delayChildren,\n      staggerChildren = _a.staggerChildren,\n      staggerDirection = _a.staggerDirection,\n      transition = __rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\"]);\n\n  return Object.keys(transition).length;\n};\n\nvar getTransitionDefinition = function getTransitionDefinition(key, to, transitionDefinition) {\n  var delay = transitionDefinition ? transitionDefinition.delay : 0; // If no object, return default transition\n  // A better way to handle this would be to deconstruct out all the shared Orchestration props\n  // and see if there's any props remaining\n\n  if (transitionDefinition === undefined || !isTransitionDefined(transitionDefinition)) {\n    return __assign({\n      delay: delay\n    }, getDefaultTransition(key, to));\n  }\n\n  var valueTransitionDefinition = transitionDefinition[key] || transitionDefinition.default || transitionDefinition;\n\n  if (valueTransitionDefinition.type === false) {\n    return {\n      delay: valueTransitionDefinition.hasOwnProperty(\"delay\") ? valueTransitionDefinition.delay : delay,\n      to: isKeyframesTarget(to) ? to[to.length - 1] : to,\n      type: \"just\"\n    };\n  } else if (isKeyframesTarget(to)) {\n    return __assign(__assign({\n      values: to,\n      duration: 0.8,\n      delay: delay,\n      ease: \"linear\"\n    }, valueTransitionDefinition), {\n      // This animation must be keyframes if we're animating through an array\n      type: \"keyframes\"\n    });\n  } else {\n    return __assign({\n      type: \"tween\",\n      to: to,\n      delay: delay\n    }, valueTransitionDefinition);\n  }\n};\n\nvar preprocessOptions = function preprocessOptions(type, opts) {\n  return transitionOptionParser[type] ? transitionOptionParser[type](opts) : opts;\n};\n\nvar getAnimation = function getAnimation(key, value, target, transition) {\n  var origin = value.get();\n  var isOriginAnimatable = isAnimatable(key, origin);\n  var isTargetAnimatable = isAnimatable(key, target); // TODO we could probably improve this check to ensure both values are of the same type -\n  // for instance 100 to #fff. This might live better in Popmotion.\n\n  warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key + \" from \\\"\" + origin + \"\\\" to \\\"\" + target + \"\\\". \" + origin + \" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\"); // Parse the `transition` prop and return options for the Popmotion animation\n\n  var _a = getTransitionDefinition(key, target, transition),\n      _b = _a.type,\n      type = _b === void 0 ? \"tween\" : _b,\n      transitionDefinition = __rest(_a, [\"type\"]); // If this is an animatable pair of values, return an animation, otherwise use `just`\n\n\n  var actionFactory = isOriginAnimatable && isTargetAnimatable ? transitions[type] : just;\n  var opts = preprocessOptions(type, __assign({\n    from: origin,\n    velocity: value.getVelocity()\n  }, transitionDefinition)); // Convert duration from Framer Motion's seconds into Popmotion's milliseconds\n\n  if (isDurationAnimation(opts)) {\n    if (opts.duration) {\n      opts.duration = secondsToMilliseconds(opts.duration);\n    }\n\n    if (opts.repeatDelay) {\n      opts.repeatDelay = secondsToMilliseconds(opts.repeatDelay);\n    }\n  }\n\n  return [actionFactory, opts];\n};\n/**\n * Start animation on a value. This function completely encapsulates Popmotion-specific logic.\n *\n * @internal\n */\n\n\nfunction startAnimation(key, value, target, _a) {\n  if (_a === void 0) {\n    _a = {};\n  }\n\n  var _b = _a.delay,\n      delay$1 = _b === void 0 ? 0 : _b,\n      transition = __rest(_a, [\"delay\"]);\n\n  return value.start(function (complete) {\n    var activeAnimation;\n\n    var _a = getAnimation(key, value, target, transition),\n        animationFactory = _a[0],\n        _b = _a[1],\n        valueDelay = _b.delay,\n        options = __rest(_b, [\"delay\"]);\n\n    if (valueDelay !== undefined) {\n      delay$1 = valueDelay;\n    }\n\n    var animate = function animate() {\n      var animation = animationFactory(options); // Bind animation opts to animation\n\n      activeAnimation = animation.start({\n        update: function update(v) {\n          return value.set(v);\n        },\n        complete: complete\n      });\n    }; // If we're delaying this animation, only resolve it **after** the delay to\n    // ensure the value's resolve velocity is up-to-date.\n\n\n    if (delay$1) {\n      activeAnimation = delay(secondsToMilliseconds(delay$1)).start({\n        complete: animate\n      });\n    } else {\n      animate();\n    }\n\n    return function () {\n      if (activeAnimation) activeAnimation.stop();\n    };\n  });\n}\n/**\n * Measure and return the element bounding box.\n *\n * We convert the box into an AxisBox2D to make it easier to work with each axis\n * individually and programmatically.\n *\n * This function optionally accepts a transformPagePoint function which allows us to compensate\n * for, for instance, measuring the element within a scaled plane like a Framer devivce preview component.\n */\n\n\nfunction getBoundingBox(element, transformPagePoint) {\n  var box = element.getBoundingClientRect();\n  return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));\n}\n/**\n * A VisualElement for HTMLElements\n */\n\n\nvar HTMLVisualElement =\n/** @class */\nfunction (_super) {\n  __extends(HTMLVisualElement, _super);\n\n  function HTMLVisualElement() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     *\n     */\n\n\n    _this.defaultConfig = {\n      enableHardwareAcceleration: true,\n      allowTransformNone: true\n    };\n    /**\n     * A mutable record of styles we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n    _this.style = {};\n    /**\n     * A record of styles we only want to apply via React. This gets set in useMotionValues\n     * and applied in the render function. I'd prefer this to live somewhere else to decouple\n     * VisualElement from React but works for now.\n     */\n\n    _this.reactStyle = {};\n    /**\n     * A mutable record of CSS variables we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n    _this.vars = {};\n    /**\n     * A mutable record of transforms we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n    _this.transform = {};\n    /**\n     * A mutable record of transform origins we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n    _this.transformOrigin = {};\n    /**\n     * A mutable record of transform keys we want to apply to the rendered Element. We order\n     * this to order transforms in the desired order. We use a mutable data structure to reduce GC during animations.\n     */\n\n    _this.transformKeys = [];\n    _this.config = _this.defaultConfig;\n    /**\n     * ========================================\n     * Layout\n     * ========================================\n     */\n\n    _this.isLayoutProjectionEnabled = false;\n    /**\n     * A boolean that flags whether this component has children that need to be update\n     * when this component changes layout.\n     */\n\n    _this.hasLayoutChildren = false;\n    /**\n     * A set of layout update event handlers. These are only called once all layouts have been read,\n     * making it safe to perform DOM write operations.\n     */\n\n    _this.layoutUpdateListeners = new Set();\n    /**\n     * Keep track of whether the viewport box has been updated since the last render.\n     * If it has, we want to fire the onViewportBoxUpdate listener.\n     */\n\n    _this.hasViewportBoxUpdated = false;\n    /**\n     * The visual target we want to project our component into on a given frame\n     * before applying transforms defined in `animate` or `style`.\n     *\n     * This is considered mutable to avoid object creation on each frame.\n     */\n\n    _this.targetBoxFinal = axisBox();\n    /**\n     * The overall scale of the local coordinate system as transformed by all parents\n     * of this component. We use this for scale correction on our calculated layouts\n     * and scale-affected values like `boxShadow`.\n     *\n     * This is considered mutable to avoid object creation on each frame.\n     */\n\n    _this.treeScale = {\n      x: 1,\n      y: 1\n    };\n    /**\n     * The delta between the boxCorrected and the desired\n     * targetBox (before user-set transforms are applied). The calculated output will be\n     * handed to the renderer and used as part of the style correction calculations, for\n     * instance calculating how to display the desired border-radius correctly.\n     *\n     * This is considered mutable to avoid object creation on each frame.\n     */\n\n    _this.delta = delta();\n    /**\n     * The delta between the boxCorrected and the desired targetBoxFinal. The calculated\n     * output will be handed to the renderer and used to project the boxCorrected into\n     * the targetBoxFinal.\n     *\n     * This is considered mutable to avoid object creation on each frame.\n     */\n\n    _this.deltaFinal = delta();\n    /**\n     *\n     */\n\n    _this.stopLayoutAxisAnimation = {\n      x: function x() {},\n      y: function y() {}\n    };\n    _this.isTargetBoxLocked = false;\n    /**\n     *\n     */\n\n    _this.axisProgress = {\n      x: motionValue(0),\n      y: motionValue(0)\n    };\n    return _this;\n  }\n  /**\n   * When a value is removed, we want to make sure it's removed from all rendered data structures.\n   */\n\n\n  HTMLVisualElement.prototype.removeValue = function (key) {\n    _super.prototype.removeValue.call(this, key);\n\n    delete this.vars[key];\n    delete this.style[key];\n  };\n  /**\n   * Empty the mutable data structures by re-creating them. We can do this every React render\n   * as the comparative workload to the rest of the render is very low and this is also when\n   * we want to reflect values that might have been removed by the render.\n   */\n\n\n  HTMLVisualElement.prototype.clean = function () {\n    this.style = {};\n    this.vars = {};\n    this.transform = {};\n  };\n\n  HTMLVisualElement.prototype.updateConfig = function (config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    this.config = __assign(__assign({}, this.defaultConfig), config);\n  };\n  /**\n   * Read a value directly from the HTMLElement style.\n   */\n\n\n  HTMLVisualElement.prototype.read = function (key) {\n    return this.getComputedStyle()[key] || 0;\n  };\n  /**\n   * Read a value directly from the HTMLElement in case it's not defined by a Motion\n   * prop. If it's a transform, we just return a pre-defined default value as reading these\n   * out of a matrix is either error-prone or can incur a big payload for little benefit.\n   */\n\n\n  HTMLVisualElement.prototype.readNativeValue = function (key) {\n    if (isTransformProp(key)) {\n      var defaultValueType = getDefaultValueType(key);\n      return defaultValueType ? defaultValueType.default || 0 : 0;\n    } else {\n      return this.read(key);\n    }\n  };\n\n  HTMLVisualElement.prototype.enableLayoutProjection = function () {\n    this.isLayoutProjectionEnabled = true;\n    forEachParent(this, function (parent) {\n      return parent.hasLayoutChildren = true;\n    });\n  };\n\n  HTMLVisualElement.prototype.hide = function () {\n    if (this.isVisible === false) return;\n    this.isVisible = false;\n    this.scheduleRender();\n  };\n\n  HTMLVisualElement.prototype.show = function () {\n    if (this.isVisible === true) return;\n    this.isVisible = true;\n    this.scheduleRender();\n  };\n  /**\n   * Register an event listener to fire when the layout is updated. We might want to expose support\n   * for this via a `motion` prop.\n   */\n\n\n  HTMLVisualElement.prototype.onLayoutUpdate = function (callback) {\n    var _this = this;\n\n    this.layoutUpdateListeners.add(callback);\n    return function () {\n      return _this.layoutUpdateListeners.delete(callback);\n    };\n  };\n  /**\n   * To be called when all layouts are successfully updated. In turn we can notify layoutUpdate\n   * subscribers.\n   */\n\n\n  HTMLVisualElement.prototype.layoutReady = function (config) {\n    var _this = this;\n\n    this.layoutUpdateListeners.forEach(function (listener) {\n      listener(_this.box, _this.prevViewportBox || _this.box, config);\n    });\n  };\n  /**\n   * Measure and return the Element's bounding box. We convert it to a AxisBox2D\n   * structure to make it easier to work on each individual axis generically.\n   */\n\n\n  HTMLVisualElement.prototype.getBoundingBox = function () {\n    var transformPagePoint = this.config.transformPagePoint;\n    return getBoundingBox(this.element, transformPagePoint);\n  };\n\n  HTMLVisualElement.prototype.getBoundingBoxWithoutTransforms = function () {\n    var bbox = this.getBoundingBox();\n    removeBoxTransforms(bbox, this.latest);\n    return bbox;\n  };\n  /**\n   * Return the computed style after a render.\n   */\n\n\n  HTMLVisualElement.prototype.getComputedStyle = function () {\n    return window.getComputedStyle(this.element);\n  };\n  /**\n   *\n   */\n\n\n  HTMLVisualElement.prototype.snapshotBoundingBox = function () {\n    this.prevViewportBox = this.getBoundingBoxWithoutTransforms();\n    /**\n     * Update targetBox to match the prevViewportBox. This is just to ensure\n     * that targetBox is affected by scroll in the same way as the measured box\n     */\n\n    var _a = this.axisProgress,\n        x = _a.x,\n        y = _a.y;\n\n    if (!this.isTargetBoxLocked && !x.isAnimating() && !y.isAnimating()) {\n      this.targetBox = copyAxisBox(this.prevViewportBox);\n    }\n  };\n\n  HTMLVisualElement.prototype.measureLayout = function () {\n    this.box = this.getBoundingBox();\n    this.boxCorrected = copyAxisBox(this.box);\n    if (!this.targetBox) this.targetBox = copyAxisBox(this.box);\n  };\n  /**\n   * Ensure the targetBox reflects the latest visual box on screen\n   */\n\n\n  HTMLVisualElement.prototype.refreshTargetBox = function () {\n    this.targetBox = this.getBoundingBoxWithoutTransforms();\n  };\n\n  HTMLVisualElement.prototype.lockTargetBox = function () {\n    this.isTargetBoxLocked = true;\n  };\n\n  HTMLVisualElement.prototype.unlockTargetBox = function () {\n    this.stopLayoutAnimation();\n    this.isTargetBoxLocked = false;\n  };\n  /**\n   * Reset the transform on the current Element. This is called as part\n   * of a batched process across the entire layout tree. To remove this write\n   * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n   * works\n   */\n\n\n  HTMLVisualElement.prototype.resetTransform = function () {\n    this.element.style.transform = \"none\"; // Ensure that whatever happens next, we restore our transform\n\n    this.scheduleRender();\n  };\n  /**\n   * Set new min/max boundaries to project an axis into\n   */\n\n\n  HTMLVisualElement.prototype.setAxisTarget = function (axis, min, max) {\n    var targetAxis = this.targetBox[axis];\n    targetAxis.min = min;\n    targetAxis.max = max; // Flag that we want to fire the onViewportBoxUpdate event handler\n\n    this.hasViewportBoxUpdated = true;\n    /**\n     * If this component re-renders we need to ensure that any children performing\n     * layout projection also update\n     *\n     * TODO: This recursively traverses all children for each axis and for each component. A performance\n     * improvement would be to:\n     *  1. Flag the root component as dirty and schedule it to update pre-render\n     *  2. Recursively traverse tree from root layout component during this update\n     *      scheduling renders and updating deltas\n     */\n\n    scheduleChildrenLayoutRender(this);\n  };\n  /**\n   *\n   */\n\n\n  HTMLVisualElement.prototype.startLayoutAxisAnimation = function (axis, transition) {\n    var _this = this;\n\n    var progress = this.axisProgress[axis];\n    var _a = this.targetBox[axis],\n        min = _a.min,\n        max = _a.max;\n    var length = max - min;\n    progress.clearListeners();\n    progress.set(min);\n    progress.set(min); // Set twice to hard-reset velocity\n\n    progress.onChange(function (v) {\n      return _this.setAxisTarget(axis, v, v + length);\n    });\n    return startAnimation(axis, progress, 0, transition);\n  };\n\n  HTMLVisualElement.prototype.stopLayoutAnimation = function () {\n    var _this = this;\n\n    eachAxis(function (axis) {\n      return _this.axisProgress[axis].stop();\n    });\n  };\n  /**\n   * Update the layout deltas to reflect the relative positions of the layout\n   * and the desired target box\n   */\n\n\n  HTMLVisualElement.prototype.updateLayoutDeltas = function (isReactRender) {\n    var _a, _b;\n    /**\n     * Ensure that all the parent deltas are up-to-date before calculating this delta.\n     *\n     * TODO: This approach is exceptionally wasteful as every child will update\n     * the deltas of its parent even if it's already updated for this frame.\n     * We can optimise this by replacing this to a call directly to the root VisualElement\n     * which then runs iteration from the top-down, but only once per framestamp.\n     */\n\n\n    this.treePath.forEach(function (p) {\n      return p.updateLayoutDeltas(isReactRender);\n    });\n    /**\n     * Early return if layout reprojection isn't enabled\n     */\n\n    if (!this.isLayoutProjectionEnabled || !this.box) return;\n    /**\n     * Reset the corrected box with the latest values from box, as we're then going\n     * to perform mutative operations on it.\n     */\n\n    resetBox(this.boxCorrected, this.box);\n    /**\n     * Apply all the parent deltas to this box to produce the corrected box. This\n     * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n     */\n\n    applyTreeDeltas(this.boxCorrected, this.treeScale, this.treePath);\n    /**\n     * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n     * This is the final box that we will then project into by calculating a transform delta and\n     * applying it to the corrected box.\n     */\n\n    applyBoxTransforms(this.targetBoxFinal, this.targetBox, this.latest);\n    /**\n     * Update the delta between the corrected box and the target box before user-set transforms were applied.\n     * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n     * for our layout reprojection, but still allow them to be scaled correctly by the user.\n     * It might be that to simplify this we may want to accept that user-set scale is also corrected\n     * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n     * to allow people to choose whether these styles are corrected based on just the\n     * layout reprojection or the final bounding box.\n     */\n\n    updateBoxDelta(this.delta, this.boxCorrected, this.targetBox);\n    /**\n     * Update the delta between the corrected box and the final target box, after\n     * user-set transforms are applied to it. This will be used by the renderer to\n     * create a transform style that will reproject the element from its actual layout\n     * into the desired bounding box.\n     */\n\n    updateBoxDelta(this.deltaFinal, this.boxCorrected, this.targetBoxFinal);\n    /**\n     * If we have a listener for the viewport box, fire it.\n     * TODO: Instead of manually checking this, use framesync postRender\n     */\n\n    if (!isReactRender) {\n      this.hasViewportBoxUpdated && ((_b = (_a = this.config).onViewportBoxUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, this.targetBox, this.delta));\n      this.hasViewportBoxUpdated = false;\n    }\n  };\n  /**\n   * ========================================\n   * Build & render\n   * ========================================\n   */\n\n  /**\n   * Build a style prop using the latest resolved MotionValues\n   */\n\n\n  HTMLVisualElement.prototype.build = function (isReactRender) {\n    if (this.isVisible !== undefined) {\n      this.style.visibility = this.isVisible ? \"visible\" : \"hidden\";\n    }\n\n    this.isLayoutProjectionEnabled && this.box && this.updateLayoutDeltas(isReactRender);\n    buildHTMLStyles(this.latest, this.style, this.vars, this.transform, this.transformOrigin, this.transformKeys, this.config, this.isLayoutProjectionEnabled && !!this.box, this.delta, this.deltaFinal, this.treeScale, this.targetBoxFinal);\n  };\n  /**\n   * Render the Element by rebuilding and applying the latest styles and vars.\n   */\n\n\n  HTMLVisualElement.prototype.render = function () {\n    // Rebuild the latest animated values into style and vars caches.\n    this.build(false); // Directly assign style into the Element's style prop. In tests Object.assign is the\n    // fastest way to assign styles.\n\n    Object.assign(this.element.style, this.style); // Loop over any CSS variables and assign those.\n\n    for (var key in this.vars) {\n      this.element.style.setProperty(key, this.vars[key]);\n    }\n  };\n\n  return HTMLVisualElement;\n}(VisualElement);\n\nfunction scheduleChildrenLayoutRender(element) {\n  if (element.isLayoutProjectionEnabled) {\n    element.scheduleRender();\n  }\n\n  if (element.hasLayoutChildren) {\n    element.children.forEach(scheduleChildrenLayoutRender);\n  }\n}\n\nfunction forEachParent(child, callback) {\n  var parent = child.parent;\n\n  while (parent) {\n    callback(parent);\n    parent = parent.parent;\n  }\n}\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\n\n\nfunction useConstant(init) {\n  var ref = useRef(null);\n\n  if (ref.current === null) {\n    ref.current = init();\n  }\n\n  return ref.current;\n}\n\nfunction calcOrigin$1(origin, offset, size) {\n  return typeof origin === \"string\" ? origin : px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\n\n\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n  var pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);\n  var pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);\n  return pxOriginX + \" \" + pxOriginY;\n} // Convert a progress 0-1 to a pixels value based on the provided length\n\n\nvar progressToPixels = function progressToPixels(progress, length) {\n  return px.transform(progress * length);\n};\n\nvar dashKeys = {\n  offset: \"stroke-dashoffset\",\n  array: \"stroke-dasharray\"\n};\nvar camelKeys = {\n  offset: \"strokeDashoffset\",\n  array: \"strokeDasharray\"\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\n\nfunction buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {\n  if (spacing === void 0) {\n    spacing = 1;\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  if (useDashCase === void 0) {\n    useDashCase = true;\n  } // We use dash case when setting attributes directly to the DOM node and camel case\n  // when defining props on a React component.\n\n\n  var keys = useDashCase ? dashKeys : camelKeys; // Build the dash offset\n\n  attrs[keys.offset] = progressToPixels(-offset, totalLength); // Build the dash array\n\n  var pathLength = progressToPixels(length, totalLength);\n  var pathSpacing = progressToPixels(spacing, totalLength);\n  attrs[keys.array] = pathLength + \" \" + pathSpacing;\n}\n\nvar unmeasured = {\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0\n};\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\n\nfunction buildSVGAttrs(_a, style, vars, attrs, transform, transformOrigin, transformKeys, config, dimensions, totalPathLength) {\n  var attrX = _a.attrX,\n      attrY = _a.attrY,\n      originX = _a.originX,\n      originY = _a.originY,\n      pathLength = _a.pathLength,\n      _b = _a.pathSpacing,\n      pathSpacing = _b === void 0 ? 1 : _b,\n      _c = _a.pathOffset,\n      pathOffset = _c === void 0 ? 0 : _c,\n      // This is object creation, which we try to avoid per-frame.\n  latest = __rest(_a, [\"attrX\", \"attrY\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\n  /**\n   * With SVG we treat all animated values as attributes rather than CSS, so we build into attrs\n   */\n\n\n  buildHTMLStyles(latest, attrs, vars, transform, transformOrigin, transformKeys, config);\n  /**\n   * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n   * and copy it into style.\n   */\n\n  if (attrs.transform) {\n    style.transform = attrs.transform;\n    delete attrs.transform;\n  } // Parse transformOrigin\n\n\n  if (originX !== undefined || originY !== undefined || style.transform) {\n    style.transformOrigin = calcSVGTransformOrigin(dimensions || unmeasured, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n  } // Treat x/y not as shortcuts but as actual attributes\n\n\n  if (attrX !== undefined) attrs.x = attrX;\n  if (attrY !== undefined) attrs.y = attrY; // Build SVG path if one has been measured\n\n  if (totalPathLength !== undefined && pathLength !== undefined) {\n    buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);\n  }\n\n  return attrs;\n}\n/**\n * A set of attribute names that are always read/written as camel case.\n */\n\n\nvar camelCaseAttributes = new Set([\"baseFrequency\", \"diffuseConstant\", \"kernelMatrix\", \"kernelUnitLength\", \"keySplines\", \"keyTimes\", \"limitingConeAngle\", \"markerHeight\", \"markerWidth\", \"numOctaves\", \"targetX\", \"targetY\", \"surfaceScale\", \"specularConstant\", \"specularExponent\", \"stdDeviation\", \"tableValues\"]);\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = \"$1-$2\";\n/**\n * Convert camelCase to dash-case properties.\n */\n\nvar camelToDash = function camelToDash(str) {\n  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\n/**\n * A VisualElement for SVGElements. Inherits from and extends HTMLVisualElement as the two\n * share data structures.\n */\n\n\nvar SVGVisualElement =\n/** @class */\nfunction (_super) {\n  __extends(SVGVisualElement, _super);\n\n  function SVGVisualElement() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * A mutable record of attributes we want to apply directly to the rendered Element\n     * every frame. We use a mutable data structure to reduce GC during animations.\n     */\n\n\n    _this.attrs = {};\n    /**\n     * We disable hardware acceleration for SVG transforms as they're not currently able to be accelerated.\n     */\n\n    _this.defaultConfig = {\n      enableHardwareAcceleration: false\n    };\n    /**\n     * Without duplicating this call from HTMLVisualElement we end up with HTMLVisualElement.defaultConfig\n     * being assigned to config\n     */\n\n    _this.config = _this.defaultConfig;\n    return _this;\n  }\n  /**\n   * Measure the SVG element on mount. This can affect page rendering so there might be a\n   * better time to perform this - for instance dynamically only if there's a transform-origin dependent\n   * transform being set (like rotate)\n   */\n\n\n  SVGVisualElement.prototype.mount = function (element) {\n    _super.prototype.mount.call(this, element);\n\n    this.measure();\n  };\n  /**\n   * Update the SVG dimensions and path length\n   */\n\n\n  SVGVisualElement.prototype.measure = function () {\n    try {\n      this.dimensions = typeof this.element.getBBox === \"function\" ? this.element.getBBox() : this.element.getBoundingClientRect();\n    } catch (e) {\n      // Most likely trying to measure an unrendered element under Firefox\n      this.dimensions = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    }\n\n    if (isPath(this.element)) {\n      this.totalPathLength = this.element.getTotalLength();\n    }\n  };\n  /**\n   * Empty the mutable data structures in case attrs have been removed between renders.\n   */\n\n\n  SVGVisualElement.prototype.clean = function () {\n    _super.prototype.clean.call(this);\n\n    this.attrs = {};\n  };\n  /**\n   * Read an attribute directly from the SVGElement\n   */\n\n\n  SVGVisualElement.prototype.read = function (key) {\n    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n    return this.element.getAttribute(key);\n  };\n\n  SVGVisualElement.prototype.build = function () {\n    buildSVGAttrs(this.latest, this.style, this.vars, this.attrs, this.transform, this.transformOrigin, this.transformKeys, this.config, this.dimensions, this.totalPathLength);\n  };\n\n  SVGVisualElement.prototype.render = function () {\n    // Update HTML styles and CSS variables\n    _super.prototype.render.call(this); // Loop through attributes and apply them to the SVGElement\n\n\n    for (var key in this.attrs) {\n      this.element.setAttribute(camelToDash(key), this.attrs[key]);\n    }\n  };\n\n  return SVGVisualElement;\n}(HTMLVisualElement);\n\nfunction isPath(element) {\n  return element.tagName === \"path\";\n}\n/**\n * @internal\n */\n\n/**\n * @internal\n */\n\n\nvar svgElements = [\"animate\", \"circle\", \"clipPath\", \"defs\", \"desc\", \"ellipse\", \"feBlend\", \"feColorMatrix\", \"feComponentTransfer\", \"feComposite\", \"feConvolveMatrix\", \"feDiffuseLighting\", \"feDisplacementMap\", \"feDistantLight\", \"feDropShadow\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feImage\", \"feMerge\", \"feMergeNode\", \"feMorphology\", \"feOffset\", \"fePointLight\", \"feSpecularLighting\", \"feSpotLight\", \"feTile\", \"feTurbulence\", \"filter\", \"foreignObject\", \"g\", \"image\", \"line\", \"linearGradient\", \"marker\", \"mask\", \"metadata\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"radialGradient\", \"rect\", \"stop\", \"svg\", \"switch\", \"symbol\", \"text\", \"textPath\", \"tspan\", \"use\", \"view\"];\nvar svgTagNames = new Set(svgElements);\n/**\n * Determine whether this is a HTML or SVG component based on if the provided\n * Component is a string and a recognised SVG tag. A potentially better way to\n * do this would be to offer a `motion.customSVG` function and determine this\n * when we generate the `motion.circle` etc components.\n */\n\nfunction isSVGComponent(Component) {\n  return typeof Component === \"string\" && svgTagNames.has(Component);\n}\n/**\n * @public\n */\n\n\nvar PresenceContext = createContext(null);\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\n\nfunction usePresence() {\n  var context = useContext(PresenceContext);\n  if (context === null) return [true, null];\n  var isPresent = context.isPresent,\n      onExitComplete = context.onExitComplete,\n      register = context.register; // It's safe to call the following hooks conditionally (after an early return) because the context will always\n  // either be null or non-null for the lifespan of the component.\n  // Replace with useOpaqueId when released in React\n\n  var id = useUniqueId();\n  useEffect(function () {\n    return register(id);\n  }, []);\n\n  var safeToRemove = function safeToRemove() {\n    return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id);\n  };\n\n  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * @public\n */\n\n\nfunction useIsPresent() {\n  var context = useContext(PresenceContext);\n  return context === null ? true : context.isPresent;\n}\n\nvar counter = 0;\n\nvar incrementId = function incrementId() {\n  return counter++;\n};\n\nvar useUniqueId = function useUniqueId() {\n  return useConstant(incrementId);\n};\n/**\n * DOM-flavoured variation of the useVisualElement hook. Used to create either a HTMLVisualElement\n * or SVGVisualElement for the component.\n */\n\n\nvar useDomVisualElement = function useDomVisualElement(Component, props, parent, isStatic, ref) {\n  var visualElement = useConstant(function () {\n    var DOMVisualElement = isSVGComponent(Component) ? SVGVisualElement : HTMLVisualElement;\n    return new DOMVisualElement(parent, ref);\n  });\n  visualElement.updateConfig(__assign({\n    enableHardwareAcceleration: !isStatic\n  }, props));\n  visualElement.layoutId = props.layoutId;\n  var isPresent = useIsPresent();\n  visualElement.isPresent = props.isPresent !== undefined ? props.isPresent : isPresent;\n  return visualElement;\n};\n/**\n * A list of all valid MotionProps.\n *\n * @internalremarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\n\n\nvar validMotionProps = new Set([\"initial\", \"animate\", \"exit\", \"style\", \"variants\", \"transition\", \"transformTemplate\", \"transformValues\", \"custom\", \"inherit\", \"static\", \"layout\", \"layoutId\", \"onLayoutAnimationComplete\", \"onViewportBoxUpdate\", \"onAnimationStart\", \"onAnimationComplete\", \"onUpdate\", \"onDragStart\", \"onDrag\", \"onDragEnd\", \"onMeasureDragConstraints\", \"onDirectionLock\", \"onDragTransitionEnd\", \"drag\", \"dragControls\", \"dragListener\", \"dragConstraints\", \"dragDirectionLock\", \"dragElastic\", \"dragMomentum\", \"dragPropagation\", \"dragTransition\", \"onPan\", \"onPanStart\", \"onPanEnd\", \"onPanSessionStart\", \"onTap\", \"onTapStart\", \"onTapCancel\", \"whileHover\", \"whileTap\", \"onHoverEnd\", \"onHoverStart\"]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\n\nfunction isValidMotionProp(key) {\n  return validMotionProps.has(key);\n}\n\nvar isPropValid = function isPropValid(key) {\n  return !isValidMotionProp(key);\n};\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\n\n\ntry {\n  var emotionIsPropValid_1 = require(\"@emotion/is-prop-valid\").default;\n\n  isPropValid = function isPropValid(key) {\n    // Handle events explicitly as Emotion validates them all as true\n    if (key.startsWith(\"on\")) {\n      return !isValidMotionProp(key);\n    } else {\n      return emotionIsPropValid_1(key);\n    }\n  };\n} catch (_a) {// We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\n\nfunction filterProps(props) {\n  var domProps = {};\n\n  for (var key in props) {\n    if (isPropValid(key)) domProps[key] = props[key];\n  }\n\n  return domProps;\n}\n\nfunction buildHTMLProps(visualElement, _a) {\n  var drag = _a.drag; // The `any` isn't ideal but it is the type of createElement props argument\n\n  var htmlProps = {\n    style: __assign(__assign(__assign({}, visualElement.reactStyle), visualElement.style), visualElement.vars)\n  };\n\n  if (!!drag) {\n    // Disable text selection\n    htmlProps.style.userSelect = \"none\"; // Disable the ghost element when a user drags\n\n    htmlProps.draggable = false;\n  }\n\n  return htmlProps;\n}\n/**\n * Build React props for SVG elements\n */\n\n\nfunction buildSVGProps(visualElement) {\n  return __assign(__assign({}, visualElement.attrs), {\n    style: __assign({}, visualElement.reactStyle)\n  });\n}\n\nfunction render(Component, props, visualElement) {\n  // Only filter props from components we control, ie `motion.div`. If this\n  // is a custom component pass along everything provided to it.\n  var forwardedProps = typeof Component === \"string\" ? filterProps(props) : props;\n  /**\n   * Every render, empty and rebuild the animated values to be applied to our Element.\n   * During animation these data structures are used in a mutable fashion to reduce\n   * garbage collection, but between renders we can flush them to remove values\n   * that might have been taken out of the provided props.\n   */\n\n  visualElement.clean();\n  visualElement.build(true); // Generate props to visually render this component\n\n  var visualProps = isSVGComponent(Component) ? buildSVGProps(visualElement) : buildHTMLProps(visualElement, props);\n  return createElement(Component, __assign(__assign(__assign({}, forwardedProps), {\n    ref: visualElement.ref\n  }), visualProps));\n}\n\nfunction isCSSVariable$1(value) {\n  return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\n\n\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\n\nfunction parseCSSVariable(current) {\n  var match = cssVariableRegex.exec(current);\n  if (!match) return [,];\n  var token = match[1],\n      fallback = match[2];\n  return [token, fallback];\n}\n\nvar maxDepth = 4;\n\nfunction getVariableValue(current, element, depth) {\n  if (depth === void 0) {\n    depth = 1;\n  }\n\n  invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\n\n  var _a = parseCSSVariable(current),\n      token = _a[0],\n      fallback = _a[1]; // No CSS variable detected\n\n\n  if (!token) return; // Attempt to read this CSS variable off the element\n\n  var resolved = window.getComputedStyle(element).getPropertyValue(token);\n\n  if (resolved) {\n    return resolved;\n  } else if (isCSSVariable$1(fallback)) {\n    // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\n\n\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n  var target = __rest(_a, []);\n\n  var element = visualElement.getInstance();\n  if (!(element instanceof HTMLElement)) return {\n    target: target,\n    transitionEnd: transitionEnd\n  }; // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n  // only if they change but I think this reads clearer and this isn't a performance-critical path.\n\n  if (transitionEnd) {\n    transitionEnd = __assign({}, transitionEnd);\n  } // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n\n\n  visualElement.forEachValue(function (value) {\n    var current = value.get();\n    if (!isCSSVariable$1(current)) return;\n    var resolved = getVariableValue(current, element);\n    if (resolved) value.set(resolved);\n  }); // Cycle through every target property and resolve CSS variables. Currently\n  // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n\n  for (var key in target) {\n    var current = target[key];\n    if (!isCSSVariable$1(current)) continue;\n    var resolved = getVariableValue(current, element);\n    if (!resolved) continue; // Clone target if it hasn't already been\n\n    target[key] = resolved; // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n    // CSS variable. This will ensure that after the animation the component will reflect\n    // changes in the value of the CSS variable.\n\n    if (transitionEnd && transitionEnd[key] === undefined) {\n      transitionEnd[key] = current;\n    }\n  }\n\n  return {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\n\nvar positionalKeys = new Set([\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\", \"x\", \"y\"]);\n\nvar isPositionalKey = function isPositionalKey(key) {\n  return positionalKeys.has(key);\n};\n\nvar hasPositionalKey = function hasPositionalKey(target) {\n  return Object.keys(target).some(isPositionalKey);\n};\n\nvar setAndResetVelocity = function setAndResetVelocity(value, to) {\n  // Looks odd but setting it twice doesn't render, it'll just\n  // set both prev and current to the latest value\n  value.set(to, false);\n  value.set(to);\n};\n\nvar isNumOrPxType = function isNumOrPxType(v) {\n  return v === number || v === px;\n};\n\nvar BoundingBoxDimension;\n\n(function (BoundingBoxDimension) {\n  BoundingBoxDimension[\"width\"] = \"width\";\n  BoundingBoxDimension[\"height\"] = \"height\";\n  BoundingBoxDimension[\"left\"] = \"left\";\n  BoundingBoxDimension[\"right\"] = \"right\";\n  BoundingBoxDimension[\"top\"] = \"top\";\n  BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\n\nvar getPosFromMatrix = function getPosFromMatrix(matrix, pos) {\n  return parseFloat(matrix.split(\", \")[pos]);\n};\n\nvar getTranslateFromMatrix = function getTranslateFromMatrix(pos2, pos3) {\n  return function (_bbox, _a) {\n    var transform = _a.transform;\n    if (transform === \"none\" || !transform) return 0;\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n\n    if (matrix3d) {\n      return getPosFromMatrix(matrix3d[1], pos3);\n    } else {\n      var matrix = transform.match(/^matrix\\((.+)\\)$/);\n\n      if (matrix) {\n        return getPosFromMatrix(matrix[1], pos2);\n      } else {\n        return 0;\n      }\n    }\n  };\n};\n\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) {\n  return !transformKeys.has(key);\n});\n\nfunction removeNonTranslationalTransform(visualElement) {\n  var removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n\n    if (value !== undefined) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  }); // Apply changes to element before measurement\n\n  if (removedTransforms.length) visualElement.render();\n  return removedTransforms;\n}\n\nvar positionalValues = {\n  // Dimensions\n  width: function width(_a) {\n    var x = _a.x;\n    return x.max - x.min;\n  },\n  height: function height(_a) {\n    var y = _a.y;\n    return y.max - y.min;\n  },\n  top: function top(_bbox, _a) {\n    var top = _a.top;\n    return parseFloat(top);\n  },\n  left: function left(_bbox, _a) {\n    var left = _a.left;\n    return parseFloat(left);\n  },\n  bottom: function bottom(_a, _b) {\n    var y = _a.y;\n    var top = _b.top;\n    return parseFloat(top) + (y.max - y.min);\n  },\n  right: function right(_a, _b) {\n    var x = _a.x;\n    var left = _b.left;\n    return parseFloat(left) + (x.max - x.min);\n  },\n  // Transform\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\n\nvar convertChangedValueTypes = function convertChangedValueTypes(target, visualElement, changedKeys) {\n  var originBbox = visualElement.getBoundingBox();\n  var elementComputedStyle = visualElement.getComputedStyle();\n  var display = elementComputedStyle.display,\n      top = elementComputedStyle.top,\n      left = elementComputedStyle.left,\n      bottom = elementComputedStyle.bottom,\n      right = elementComputedStyle.right,\n      transform = elementComputedStyle.transform;\n  var originComputedStyle = {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    transform: transform\n  }; // If the element is currently set to display: \"none\", make it visible before\n  // measuring the target bounding box\n\n  if (display === \"none\") {\n    visualElement.setStaticValues(\"display\", target.display || \"block\");\n  } // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n\n\n  visualElement.render();\n  var targetBbox = visualElement.getBoundingBox();\n  changedKeys.forEach(function (key) {\n    // Restore styles to their **calculated computed style**, not their actual\n    // originally set style. This allows us to animate between equivalent pixel units.\n    var value = visualElement.getValue(key);\n    setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\n\nvar checkAndConvertChangedValueTypes = function checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) {\n  if (origin === void 0) {\n    origin = {};\n  }\n\n  if (transitionEnd === void 0) {\n    transitionEnd = {};\n  }\n\n  target = __assign({}, target);\n  transitionEnd = __assign({}, transitionEnd);\n  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey); // We want to remove any transform values that could affect the element's bounding box before\n  // it's measured. We'll reapply these later.\n\n  var removedTransformValues = [];\n  var hasAttemptedToRemoveTransformValues = false;\n  var changedValueTypeKeys = [];\n  targetPositionalKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key)) return;\n    var from = origin[key];\n    var to = target[key];\n    var fromType = findDimensionValueType(from);\n    var toType; // TODO: The current implementation of this basically throws an error\n    // if you try and do value conversion via keyframes. There's probably\n    // a way of doing this but the performance implications would need greater scrutiny,\n    // as it'd be doing multiple resize-remeasure operations.\n\n    if (isKeyframesTarget(to)) {\n      var numKeyframes = to.length;\n\n      for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\n        if (!toType) {\n          toType = findDimensionValueType(to[i]);\n          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n\n    if (fromType !== toType) {\n      // If they're both just number or px, convert them both to numbers rather than\n      // relying on resize/remeasure to convert (which is wasteful in this situation)\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        var current = value.get();\n\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else {\n        // If we're going to do value conversion via DOM measurements, we first\n        // need to remove non-positional transform values that could affect the bbox measurements.\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];\n        setAndResetVelocity(value, to);\n      }\n    }\n  });\n\n  if (changedValueTypeKeys.length) {\n    var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys); // If we removed transform values, reapply them before the next render\n\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(function (_a) {\n        var key = _a[0],\n            value = _a[1];\n        visualElement.getValue(key).set(value);\n      });\n    } // Reapply original values\n\n\n    visualElement.render();\n    return {\n      target: convertedTarget,\n      transitionEnd: transitionEnd\n    };\n  } else {\n    return {\n      target: target,\n      transitionEnd: transitionEnd\n    };\n  }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\n\n\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */\n\n\nvar parseDomVariant = function parseDomVariant(visualElement, target, origin, transitionEnd) {\n  var resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n  target = resolved.target;\n  transitionEnd = resolved.transitionEnd;\n  return unitConversion(visualElement, target, origin, transitionEnd);\n};\n/**\n * Use callback either only on the initial render or on all renders. In concurrent mode\n * the \"initial\" render might run multiple times\n *\n * @param callback - Callback to run\n * @param isInitialOnly - Set to `true` to only run on initial render, or `false` for all renders. Defaults to `false`.\n *\n * @public\n */\n\n\nfunction useInitialOrEveryRender(callback, isInitialOnly) {\n  if (isInitialOnly === void 0) {\n    isInitialOnly = false;\n  }\n\n  var isInitialRender = useRef(true);\n\n  if (!isInitialOnly || isInitialOnly && isInitialRender.current) {\n    callback();\n  }\n\n  isInitialRender.current = false;\n}\n/**\n * Control animations on one or more components.\n *\n * @public\n */\n\n\nvar AnimationControls =\n/** @class */\nfunction () {\n  function AnimationControls() {\n    /**\n     * Track whether the host component has mounted.\n     *\n     * @internal\n     */\n    this.hasMounted = false;\n    /**\n     * Pending animations that are started before a component is mounted.\n     *\n     * @internal\n     */\n\n    this.pendingAnimations = [];\n    /**\n     * A collection of linked component animation controls.\n     *\n     * @internal\n     */\n\n    this.componentControls = new Set();\n  }\n  /**\n   * Set variants on this and all child components.\n   *\n   * @param variants - The variants to set\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.setVariants = function (variants) {\n    this.variants = variants;\n    this.componentControls.forEach(function (controls) {\n      return controls.setVariants(variants);\n    });\n  };\n  /**\n   * Set a default transition on this and all child components\n   *\n   * @param transition - The default transition to set\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.setDefaultTransition = function (transition) {\n    this.defaultTransition = transition;\n    this.componentControls.forEach(function (controls) {\n      return controls.setDefaultTransition(transition);\n    });\n  };\n  /**\n   * Subscribes a component's animation controls to this.\n   *\n   * @param controls - The controls to subscribe\n   * @returns An unsubscribe function.\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.subscribe = function (controls) {\n    var _this = this;\n\n    this.componentControls.add(controls);\n    if (this.variants) controls.setVariants(this.variants);\n    if (this.defaultTransition) controls.setDefaultTransition(this.defaultTransition);\n    return function () {\n      return _this.componentControls.delete(controls);\n    };\n  };\n  /**\n   * Starts an animation on all linked components.\n   *\n   * @remarks\n   *\n   * ```jsx\n   * controls.start(\"variantLabel\")\n   * controls.start({\n   *   x: 0,\n   *   transition: { duration: 1 }\n   * })\n   * ```\n   *\n   * @param definition - Properties or variant label to animate to\n   * @param transition - Optional `transtion` to apply to a variant\n   * @returns - A `Promise` that resolves when all animations have completed.\n   *\n   * @public\n   */\n\n\n  AnimationControls.prototype.start = function (definition, transitionOverride) {\n    var _this = this;\n\n    if (this.hasMounted) {\n      var animations_1 = [];\n      this.componentControls.forEach(function (controls) {\n        var animation = controls.start(definition, {\n          transitionOverride: transitionOverride\n        });\n        animations_1.push(animation);\n      });\n      return Promise.all(animations_1);\n    } else {\n      return new Promise(function (resolve) {\n        _this.pendingAnimations.push({\n          animation: [definition, transitionOverride],\n          resolve: resolve\n        });\n      });\n    }\n  };\n  /**\n   * Instantly set to a set of properties or a variant.\n   *\n   * ```jsx\n   * // With properties\n   * controls.set({ opacity: 0 })\n   *\n   * // With variants\n   * controls.set(\"hidden\")\n   * ```\n   *\n   * @internalremarks\n   * We could perform a similar trick to `.start` where this can be called before mount\n   * and we maintain a list of of pending actions that get applied on mount. But the\n   * expectation of `set` is that it happens synchronously and this would be difficult\n   * to do before any children have even attached themselves. It's also poor practise\n   * and we should discourage render-synchronous `.start` calls rather than lean into this.\n   *\n   * @public\n   */\n\n\n  AnimationControls.prototype.set = function (definition) {\n    invariant(this.hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n    return this.componentControls.forEach(function (controls) {\n      return controls.apply(definition);\n    });\n  };\n  /**\n   * Stops animations on all linked components.\n   *\n   * ```jsx\n   * controls.stop()\n   * ```\n   *\n   * @public\n   */\n\n\n  AnimationControls.prototype.stop = function () {\n    this.componentControls.forEach(function (controls) {\n      return controls.stop();\n    });\n  };\n  /**\n   * Initialises the animation controls.\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.mount = function () {\n    var _this = this;\n\n    this.hasMounted = true;\n    this.pendingAnimations.forEach(function (_a) {\n      var animation = _a.animation,\n          resolve = _a.resolve;\n      return _this.start.apply(_this, animation).then(resolve);\n    });\n  };\n  /**\n   * Stops all child animations when the host component unmounts.\n   *\n   * @internal\n   */\n\n\n  AnimationControls.prototype.unmount = function () {\n    this.hasMounted = false;\n    this.stop();\n  };\n\n  return AnimationControls;\n}();\n/**\n * @internal\n */\n\n\nvar animationControls = function animationControls() {\n  return new AnimationControls();\n};\n/**\n * @internal\n */\n\n\nvar MotionContext = createContext({\n  static: false\n});\n\nvar isVariantLabel = function isVariantLabel(v) {\n  return typeof v === \"string\" || Array.isArray(v);\n};\n\nvar isAnimationControls = function isAnimationControls(v) {\n  return v instanceof AnimationControls;\n};\n/**\n * Set up the context for children motion components.\n *\n * We also use this opportunity to apply `initial` values\n */\n\n\nvar useMotionContext = function useMotionContext(parentContext, controls, visualElement, isStatic, _a) {\n  if (isStatic === void 0) {\n    isStatic = false;\n  }\n\n  var initial = _a.initial,\n      animate = _a.animate,\n      variants = _a.variants,\n      whileTap = _a.whileTap,\n      whileHover = _a.whileHover,\n      layoutId = _a.layoutId; // Determine whether this is a root element of an AnimatePresence component\n\n  var presenceContext = useContext(PresenceContext);\n  var presenceId = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id;\n  visualElement.isPresenceRoot = parentContext.presenceId !== presenceId; // Override initial with that from a parent context, if defined\n\n  if ((presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) !== undefined) {\n    initial = presenceContext.initial;\n  }\n\n  var initialState;\n\n  if (initial === false && !isAnimationControls(animate)) {\n    initialState = animate;\n  } else if (typeof initial !== \"boolean\") {\n    initialState = initial;\n  } // Track mounted status so children can detect whether they were present during their\n  // parent's first render\n\n\n  var hasMounted = useRef(false); // We propagate this component's VisualElementAnimationControls *if* we're being provided variants,\n  // if we're being used to control variants, or if we're being passed animation controls.\n  // Otherwise this component should be \"invisible\" to variant propagation. This is a slight concession\n  // to Framer X where every `Frame` is a `motion` component and it might be if we change that in the future\n  // that this restriction is removed.\n\n  var shouldPropagateControls = variants || isVariantLabel(animate) || isVariantLabel(whileTap) || isVariantLabel(whileHover) || isAnimationControls(animate); // If this component's `initial` prop is a variant label, propagate it. Otherwise pass the parent's.\n\n  var targetInitial = isVariantLabel(initialState) ? initialState : parentContext.initial; // If this is a variant tree we need to propagate the `animate` prop in case new children are added after\n  // the tree initially animates.\n\n  var targetAnimate = isVariantLabel(animate) ? animate : parentContext.animate; // Only allow `initial` to trigger context re-renders if this is a `static` component (ie we're on the Framer canvas)\n  // or in another non-animation/interaction environment.\n\n  var initialDependency = isStatic ? targetInitial : null; // Only allow `animate` to trigger context re-renders if it's a variant label. If this is an array of\n  // variant labels there's probably an optimisation to deep-compare but it might be an over-optimisation.\n  // We want to do this as we rely on React's component rendering order each render cycle to determine\n  // the new order of any child components for the `staggerChildren` functionality.\n\n  var animateDependency = shouldPropagateControls && isVariantLabel(targetAnimate) ? targetAnimate : null; // The context to provide to the child. We `useMemo` because although `controls` and `initial` are\n  // unlikely to change, by making the context an object it'll be considered a new value every render.\n  // So all child motion components will re-render as a result.\n\n  var context = useMemo(function () {\n    return {\n      controls: shouldPropagateControls ? controls : parentContext.controls,\n      initial: targetInitial,\n      animate: targetAnimate,\n      visualElement: visualElement,\n      hasMounted: hasMounted,\n      isReducedMotion: parentContext.isReducedMotion,\n      presenceId: presenceId\n    };\n  }, [initialDependency, animateDependency, parentContext.isReducedMotion, animate, layoutId, presenceId]); // Update the `static` property every render. This is unlikely to change but also essentially free.\n\n  context.static = isStatic; // Set initial state. If this is a static component (ie in Framer canvas), respond to updates\n  // in `initial`.\n\n  useInitialOrEveryRender(function () {\n    var initialToApply = initialState || parentContext.initial;\n    initialToApply && controls.apply(initialToApply);\n  }, !isStatic);\n  useEffect(function () {\n    hasMounted.current = true;\n  }, []);\n  return context;\n};\n\nvar checkShouldInheritVariant = function checkShouldInheritVariant(_a) {\n  var animate = _a.animate,\n      variants = _a.variants,\n      _b = _a.inherit,\n      inherit = _b === void 0 ? true : _b;\n  return inherit && !!variants && (!animate || animate instanceof AnimationControls);\n};\n\nvar isMotionValue = function isMotionValue(value) {\n  return value instanceof MotionValue;\n};\n/**\n * Scrape props for MotionValues and add/remove them to this component's\n * VisualElement\n */\n\n\nfunction useMotionValues(visualElement, props) {\n  var prev = useConstant(empty);\n  /**\n   * Remove MotionValues that are no longer present\n   */\n\n  for (var key in prev) {\n    var isTransform = isTransformProp(key) || isTransformOriginProp(key);\n    var existsAsProp = props[key];\n    var existsAsStyle = props.style && props.style[key];\n    var propIsMotionValue = existsAsProp && isMotionValue(props[key]);\n    var styleIsMotionValue = existsAsStyle && isMotionValue(props.style[key]);\n    var transformRemoved = isTransform && !existsAsProp && !existsAsStyle;\n    var motionValueRemoved = !isTransform && !propIsMotionValue && !styleIsMotionValue;\n\n    if (transformRemoved || motionValueRemoved) {\n      visualElement.removeValue(key);\n      delete prev[key];\n    }\n  }\n  /**\n   * Add incoming MotionValues\n   */\n\n\n  addMotionValues(visualElement, prev, props);\n  if (props.style) addMotionValues(visualElement, prev, props.style, true);\n  /**\n   * Transform custom values if provided a handler, ie size -> width/height\n   * Ideally we'd ditch this by removing support for size and other custom values from Framer.\n   */\n\n  if (props.transformValues) {\n    visualElement.reactStyle = props.transformValues(visualElement.reactStyle);\n  }\n}\n/**\n * Add incoming MotionValues\n *\n * TODO: Type the VisualElements properly\n */\n\n\nfunction addMotionValues(visualElement, prev, source, isStyle) {\n  if (isStyle === void 0) {\n    isStyle = false;\n  }\n\n  if (isStyle) visualElement.reactStyle = {};\n\n  for (var key in source) {\n    var value = source[key];\n    var foundMotionValue = false;\n\n    if (isMotionValue(value)) {\n      // If this is a MotionValue, add it if it isn't a reserved key\n      if (!reservedNames.has(key)) {\n        visualElement.addValue(key, value);\n        foundMotionValue = true;\n      }\n    } else if (isTransformProp(key) || isTransformOriginProp(key)) {\n      // If this is a transform prop, always create a MotionValue\n      // to ensure we can reconcile them all together.\n      if (!visualElement.hasValue(key)) {\n        visualElement.addValue(key, motionValue(value));\n      } else if (value !== prev[key]) {\n        // If the MotionValue already exists, update it with the\n        // latest incoming value\n        var motion = visualElement.getValue(key);\n        motion.set(value);\n      }\n\n      foundMotionValue = true;\n    } else if (isStyle) {\n      visualElement.reactStyle[key] = value;\n    }\n\n    if (foundMotionValue) prev[key] = value;\n  }\n}\n/**\n * These are props we accept as MotionValues but don't want to add\n * to the VisualElement\n */\n\n\nvar reservedNames = new Set([]);\n\nvar empty = function empty() {\n  return {};\n};\n\nvar isCustomValue = function isCustomValue(v) {\n  return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\n\nvar resolveFinalValueInKeyframes = function resolveFinalValueInKeyframes(v) {\n  // TODO maybe throw if v.length - 1 is placeholder token?\n  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\n\n\nvar isNumericalString = function isNumericalString(v) {\n  return /^\\-?\\d*\\.?\\d+$/.test(v);\n};\n/**\n * Get the current value of every `MotionValue` in a `VisualElement`\n */\n\n\nvar getCurrent = function getCurrent(visualElement) {\n  var current = {};\n  visualElement.forEachValue(function (value, key) {\n    return current[key] = value.get();\n  });\n  return current;\n};\n/**\n * Get the current velocity of every `MotionValue` in a `VisualElement`\n */\n\n\nvar getVelocity = function getVelocity(visualElement) {\n  var velocity = {};\n  visualElement.forEachValue(function (value, key) {\n    return velocity[key] = value.getVelocity();\n  });\n  return velocity;\n};\n/**\n * Check if value is a function that returns a `Target`. A generic typeof === 'function'\n * check, just helps with typing.\n */\n\n\nvar isTargetResolver = function isTargetResolver(p) {\n  return typeof p === \"function\";\n};\n/**\n * Check if value is a list of variant labels\n */\n\n\nvar isVariantLabels = function isVariantLabels(v) {\n  return Array.isArray(v);\n};\n/**\n * Control animations for a single component\n *\n * @internal\n */\n\n\nvar VisualElementAnimationControls =\n/** @class */\nfunction () {\n  function VisualElementAnimationControls(visualElement, _a) {\n    var _this = this;\n\n    var makeTargetAnimatable = _a.makeTargetAnimatable;\n    /**\n     * A reference to the component's latest props. We could probably ditch this in\n     * favour to a reference to the `custom` prop now we don't send all props through\n     * to target resolvers.\n     */\n\n    this.props = {};\n    /**\n     * The component's variants, as provided by `variants`\n     */\n\n    this.variants = {};\n    /**\n     * A set of values that we animate back to when a value is cleared of all overrides.\n     */\n\n    this.baseTarget = {};\n    /**\n     * A series of target overrides that we can animate to/from when overrides are set/cleared.\n     */\n\n    this.overrides = [];\n    /**\n     * A series of target overrides as they were originally resolved.\n     */\n\n    this.resolvedOverrides = [];\n    /**\n     * A Set of currently active override indexes\n     */\n\n    this.activeOverrides = new Set();\n    /**\n     * A Set of value keys that are currently animating.\n     */\n\n    this.isAnimating = new Set();\n    /**\n     * Check if the associated `VisualElement` has a key with the provided string.\n     * Pre-bound to the class so we can provide directly to the `filter` in `checkForNewValues`.\n     */\n\n    this.hasValue = function (key) {\n      return !_this.visualElement.hasValue(key);\n    };\n\n    this.visualElement = visualElement;\n    this.makeTargetAnimatable = makeTargetAnimatable;\n    this.visualElement.forEachValue(function (value, key) {\n      return _this.baseTarget[key] = value.get();\n    });\n  }\n  /**\n   * Set the reference to the component's props.\n   * @param props -\n   */\n\n\n  VisualElementAnimationControls.prototype.setProps = function (props) {\n    this.props = props;\n  };\n  /**\n   * Set the reference to the component's variants\n   * @param variants -\n   */\n\n\n  VisualElementAnimationControls.prototype.setVariants = function (variants) {\n    if (variants) this.variants = variants;\n  };\n  /**\n   * Set the component's default transition\n   * @param transition -\n   */\n\n\n  VisualElementAnimationControls.prototype.setDefaultTransition = function (transition) {\n    if (transition) this.defaultTransition = transition;\n  };\n  /**\n   * Set motion values without animation.\n   *\n   * @param definition -\n   * @param isActive -\n   */\n\n\n  VisualElementAnimationControls.prototype.setValues = function (definition, _a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.isActive,\n        isActive = _c === void 0 ? new Set() : _c,\n        priority = _b.priority;\n\n    var _d = this.resolveVariant(definition),\n        target = _d.target,\n        transitionEnd = _d.transitionEnd;\n\n    target = this.transformValues(__assign(__assign({}, target), transitionEnd));\n\n    for (var key in target) {\n      if (isActive.has(key)) return;\n      isActive.add(key);\n\n      if (target) {\n        var targetValue = resolveFinalValueInKeyframes(target[key]);\n\n        if (this.visualElement.hasValue(key)) {\n          var value = this.visualElement.getValue(key);\n          value && value.set(targetValue);\n        } else {\n          this.visualElement.addValue(key, motionValue(targetValue));\n        }\n\n        if (!priority) this.baseTarget[key] = targetValue;\n      }\n    }\n  };\n  /**\n   * Allows `transformValues` to be set by a component that allows us to\n   * transform the values in a given `Target`. This allows Framer Library\n   * to extend Framer Motion to animate `Color` variables etc. Currently we have\n   * to manually support these extended types here in Framer Motion.\n   *\n   * @param values -\n   */\n\n\n  VisualElementAnimationControls.prototype.transformValues = function (values) {\n    var transformValues = this.props.transformValues;\n    return transformValues ? transformValues(values) : values;\n  };\n  /**\n   * Check a `Target` for new values we haven't animated yet, and add them\n   * to the `MotionValueMap`.\n   *\n   * Currently there's functionality here that is DOM-specific, we should allow\n   * this functionality to be injected by the factory that creates DOM-specific\n   * components.\n   *\n   * @param target -\n   */\n\n\n  VisualElementAnimationControls.prototype.checkForNewValues = function (target) {\n    var newValueKeys = Object.keys(target).filter(this.hasValue);\n    var numNewValues = newValueKeys.length;\n    if (!numNewValues) return;\n\n    for (var i = 0; i < numNewValues; i++) {\n      var key = newValueKeys[i];\n      var targetValue = target[key];\n      var value = null; // If this is a keyframes value, we can attempt to use the first value in the\n      // array as that's going to be the first value of the animation anyway\n\n      if (Array.isArray(targetValue)) {\n        value = targetValue[0];\n      } // If it isn't a keyframes or the first keyframes value was set as `null`, read the\n      // value from the DOM. It might be worth investigating whether to check props (for SVG)\n      // or props.style (for HTML) if the value exists there before attempting to read.\n\n\n      if (value === null) {\n        var readValue = this.visualElement.readNativeValue(key);\n        value = readValue !== undefined ? readValue : target[key];\n        invariant(value !== null, \"No initial value for \\\"\" + key + \"\\\" can be inferred. Ensure an initial value for \\\"\" + key + \"\\\" is defined on the component.\");\n      }\n\n      if (typeof value === \"string\" && isNumericalString(value)) {\n        // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n        value = parseFloat(value);\n      } else if (!findValueType(value) && complex.test(targetValue)) {\n        // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n        value = complex.getAnimatableNone(targetValue);\n      }\n\n      this.visualElement.addValue(key, motionValue(value));\n      this.baseTarget[key] = value;\n    }\n  };\n  /**\n   * Resolve a variant from its label or resolver into an actual `Target` we can animate to.\n   * @param variant -\n   */\n\n\n  VisualElementAnimationControls.prototype.resolveVariant = function (variant) {\n    if (!variant) {\n      return {\n        target: undefined,\n        transition: undefined,\n        transitionEnd: undefined\n      };\n    }\n\n    if (isTargetResolver(variant)) {\n      // resolve current and velocity\n      variant = variant(this.props.custom, getCurrent(this.visualElement), getVelocity(this.visualElement));\n    }\n\n    var _a = variant.transition,\n        transition = _a === void 0 ? this.defaultTransition : _a,\n        transitionEnd = variant.transitionEnd,\n        target = __rest(variant, [\"transition\", \"transitionEnd\"]);\n\n    return {\n      transition: transition,\n      transitionEnd: transitionEnd,\n      target: target\n    };\n  };\n  /**\n   * Get the highest active override priority index\n   */\n\n\n  VisualElementAnimationControls.prototype.getHighestPriority = function () {\n    if (!this.activeOverrides.size) return 0;\n    return Math.max.apply(Math, Array.from(this.activeOverrides));\n  };\n  /**\n   * Set an override. We add this layer of indirection so if, for instance, a tap gesture\n   * starts and overrides a hover gesture, when we clear the tap gesture and fallback to the\n   * hover gesture, if that hover gesture has changed in the meantime we can go to that rather\n   * than the one that was resolved when the hover gesture animation started.\n   *\n   * @param definition -\n   * @param overrideIndex -\n   */\n\n\n  VisualElementAnimationControls.prototype.setOverride = function (definition, overrideIndex) {\n    this.overrides[overrideIndex] = definition;\n\n    if (this.children) {\n      this.children.forEach(function (child) {\n        return child.setOverride(definition, overrideIndex);\n      });\n    }\n  };\n  /**\n   * Start an override animation.\n   * @param overrideIndex -\n   */\n\n\n  VisualElementAnimationControls.prototype.startOverride = function (overrideIndex) {\n    var override = this.overrides[overrideIndex];\n\n    if (override) {\n      return this.start(override, {\n        priority: overrideIndex\n      });\n    }\n  };\n  /**\n   * Clear an override. We check every value we animated to in this override to see if\n   * its present on any lower-priority overrides. If not, we animate it back to its base target.\n   * @param overrideIndex -\n   */\n\n\n  VisualElementAnimationControls.prototype.clearOverride = function (overrideIndex) {\n    var _this = this;\n\n    if (this.children) {\n      this.children.forEach(function (child) {\n        return child.clearOverride(overrideIndex);\n      });\n    }\n\n    var override = this.overrides[overrideIndex];\n    if (!override) return;\n    this.activeOverrides.delete(overrideIndex);\n    var highest = this.getHighestPriority();\n    this.resetIsAnimating();\n\n    if (highest) {\n      var highestOverride = this.overrides[highest];\n      highestOverride && this.startOverride(highest);\n    } // Figure out which remaining values were affected by the override and animate those\n\n\n    var overrideTarget = this.resolvedOverrides[overrideIndex];\n    if (!overrideTarget) return;\n    var remainingValues = {};\n\n    for (var key in this.baseTarget) {\n      if (overrideTarget[key] !== undefined) {\n        remainingValues[key] = this.baseTarget[key];\n      }\n    }\n\n    this.onStart();\n    this.animate(remainingValues).then(function () {\n      return _this.onComplete();\n    });\n  };\n  /**\n   * Apply a target/variant without any animation\n   */\n\n\n  VisualElementAnimationControls.prototype.apply = function (definition) {\n    if (Array.isArray(definition)) {\n      return this.applyVariantLabels(definition);\n    } else if (typeof definition === \"string\") {\n      return this.applyVariantLabels([definition]);\n    } else {\n      this.setValues(definition);\n    }\n  };\n  /**\n   * Apply variant labels without animation\n   */\n\n\n  VisualElementAnimationControls.prototype.applyVariantLabels = function (variantLabelList) {\n    var _this = this;\n\n    var isActive = new Set();\n\n    var reversedList = __spreadArrays(variantLabelList).reverse();\n\n    reversedList.forEach(function (key) {\n      var _a = _this.resolveVariant(_this.variants[key]),\n          target = _a.target,\n          transitionEnd = _a.transitionEnd;\n\n      if (transitionEnd) {\n        _this.setValues(transitionEnd, {\n          isActive: isActive\n        });\n      }\n\n      if (target) {\n        _this.setValues(target, {\n          isActive: isActive\n        });\n      }\n\n      if (_this.children && _this.children.size) {\n        _this.children.forEach(function (child) {\n          return child.applyVariantLabels(variantLabelList);\n        });\n      }\n    });\n  };\n\n  VisualElementAnimationControls.prototype.start = function (definition, opts) {\n    var _this = this;\n\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    if (opts.priority) {\n      this.activeOverrides.add(opts.priority);\n    }\n\n    this.resetIsAnimating(opts.priority);\n    var animation;\n\n    if (isVariantLabels(definition)) {\n      animation = this.animateVariantLabels(definition, opts);\n    } else if (typeof definition === \"string\") {\n      animation = this.animateVariant(definition, opts);\n    } else {\n      animation = this.animate(definition, opts);\n    }\n\n    this.onStart();\n    return animation.then(function () {\n      return _this.onComplete();\n    });\n  };\n\n  VisualElementAnimationControls.prototype.animate = function (animationDefinition, _a) {\n    var _this = this;\n\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.delay,\n        delay = _c === void 0 ? 0 : _c,\n        _d = _b.priority,\n        priority = _d === void 0 ? 0 : _d,\n        transitionOverride = _b.transitionOverride;\n\n    var _e = this.resolveVariant(animationDefinition),\n        target = _e.target,\n        transition = _e.transition,\n        transitionEnd = _e.transitionEnd;\n\n    if (transitionOverride) {\n      transition = transitionOverride;\n    }\n\n    if (!target) return Promise.resolve();\n    target = this.transformValues(target);\n\n    if (transitionEnd) {\n      transitionEnd = this.transformValues(transitionEnd);\n    }\n\n    this.checkForNewValues(target);\n    var origin = this.transformValues(getOrigin(target, transition, this.visualElement));\n\n    if (this.makeTargetAnimatable) {\n      var animatable = this.makeTargetAnimatable(this.visualElement, target, origin, transitionEnd);\n      target = animatable.target;\n      transitionEnd = animatable.transitionEnd;\n    }\n\n    if (priority) {\n      this.resolvedOverrides[priority] = target;\n    }\n\n    this.checkForNewValues(target);\n    var animations = [];\n\n    for (var key in target) {\n      var value = this.visualElement.getValue(key);\n      if (!value || !target || target[key] === undefined) continue;\n      var valueTarget = target[key];\n\n      if (!priority) {\n        this.baseTarget[key] = resolveFinalValueInKeyframes(valueTarget);\n      }\n\n      if (this.isAnimating.has(key)) continue;\n      this.isAnimating.add(key);\n      animations.push(startAnimation(key, value, valueTarget, __assign({\n        delay: delay\n      }, transition)));\n    }\n\n    var allAnimations = Promise.all(animations);\n    return transitionEnd ? allAnimations.then(function () {\n      _this.setValues(transitionEnd, {\n        priority: priority\n      });\n    }) : allAnimations;\n  };\n\n  VisualElementAnimationControls.prototype.animateVariantLabels = function (variantLabels, opts) {\n    var _this = this;\n\n    var animations = __spreadArrays(variantLabels).reverse().map(function (label) {\n      return _this.animateVariant(label, opts);\n    });\n\n    return Promise.all(animations);\n  };\n\n  VisualElementAnimationControls.prototype.animateVariant = function (variantLabel, opts) {\n    var _this = this;\n\n    var when = false;\n    var delayChildren = 0;\n    var staggerChildren = 0;\n    var staggerDirection = 1;\n    var priority = opts && opts.priority || 0;\n    var variant = this.variants[variantLabel];\n    var getAnimations = variant ? function () {\n      return _this.animate(variant, opts);\n    } : function () {\n      return Promise.resolve();\n    };\n    var getChildrenAnimations = this.children ? function () {\n      return _this.animateChildren(variantLabel, delayChildren, staggerChildren, staggerDirection, priority);\n    } : function () {\n      return Promise.resolve();\n    };\n\n    if (variant && this.children) {\n      var transition = this.resolveVariant(variant).transition;\n\n      if (transition) {\n        when = transition.when || when;\n        delayChildren = transition.delayChildren || delayChildren;\n        staggerChildren = transition.staggerChildren || staggerChildren;\n        staggerDirection = transition.staggerDirection || staggerDirection;\n      }\n    }\n\n    if (when) {\n      var _a = when === \"beforeChildren\" ? [getAnimations, getChildrenAnimations] : [getChildrenAnimations, getAnimations],\n          first = _a[0],\n          last = _a[1];\n\n      return first().then(last);\n    } else {\n      return Promise.all([getAnimations(), getChildrenAnimations()]);\n    }\n  };\n\n  VisualElementAnimationControls.prototype.animateChildren = function (variantLabel, delayChildren, staggerChildren, staggerDirection, priority) {\n    if (delayChildren === void 0) {\n      delayChildren = 0;\n    }\n\n    if (staggerChildren === void 0) {\n      staggerChildren = 0;\n    }\n\n    if (staggerDirection === void 0) {\n      staggerDirection = 1;\n    }\n\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    if (!this.children) {\n      return Promise.resolve();\n    }\n\n    var animations = [];\n    var maxStaggerDuration = (this.children.size - 1) * staggerChildren;\n    var generateStaggerDuration = staggerDirection === 1 ? function (i) {\n      return i * staggerChildren;\n    } : function (i) {\n      return maxStaggerDuration - i * staggerChildren;\n    };\n    Array.from(this.children).forEach(function (childControls, i) {\n      var animation = childControls.animateVariant(variantLabel, {\n        priority: priority,\n        delay: delayChildren + generateStaggerDuration(i)\n      });\n      animations.push(animation);\n    });\n    return Promise.all(animations);\n  };\n\n  VisualElementAnimationControls.prototype.onStart = function () {\n    var onAnimationStart = this.props.onAnimationStart;\n    onAnimationStart && onAnimationStart();\n  };\n\n  VisualElementAnimationControls.prototype.onComplete = function () {\n    var onAnimationComplete = this.props.onAnimationComplete;\n    onAnimationComplete && onAnimationComplete();\n  };\n\n  VisualElementAnimationControls.prototype.checkOverrideIsAnimating = function (priority) {\n    var numOverrides = this.overrides.length;\n\n    for (var i = priority + 1; i < numOverrides; i++) {\n      var resolvedOverride = this.resolvedOverrides[i];\n\n      if (resolvedOverride) {\n        for (var key in resolvedOverride) {\n          this.isAnimating.add(key);\n        }\n      }\n    }\n  };\n\n  VisualElementAnimationControls.prototype.resetIsAnimating = function (priority) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    this.isAnimating.clear(); // If this isn't the highest priority gesture, block the animation\n    // of anything that's currently being animated\n\n    if (priority < this.getHighestPriority()) {\n      this.checkOverrideIsAnimating(priority);\n    }\n\n    if (this.children) {\n      this.children.forEach(function (child) {\n        return child.resetIsAnimating(priority);\n      });\n    }\n  };\n\n  VisualElementAnimationControls.prototype.stop = function () {\n    this.visualElement.forEachValue(function (value) {\n      return value.stop();\n    });\n  };\n  /**\n   * Add the controls of a child component.\n   * @param controls -\n   */\n\n\n  VisualElementAnimationControls.prototype.addChild = function (controls) {\n    if (!this.children) {\n      this.children = new Set();\n    }\n\n    this.children.add(controls); // We set child overrides when `setOverride` is called, but also have to do it here\n    // as the first time `setOverride` is called all the children might not have been added yet.\n\n    this.overrides.forEach(function (override, i) {\n      override && controls.setOverride(override, i);\n    });\n  };\n\n  VisualElementAnimationControls.prototype.removeChild = function (controls) {\n    if (!this.children) {\n      return;\n    }\n\n    this.children.delete(controls);\n  };\n\n  VisualElementAnimationControls.prototype.resetChildren = function () {\n    if (this.children) this.children.clear();\n  };\n\n  return VisualElementAnimationControls;\n}();\n\nfunction getOriginFromTransition(key, transition) {\n  if (!transition) return;\n  var valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\n\nfunction getOrigin(target, transition, visualElement) {\n  var _a, _b;\n\n  var origin = {};\n\n  for (var key in target) {\n    origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\n  }\n\n  return origin;\n}\n/**\n * Creates an imperative set of controls to trigger animations.\n *\n * This allows a consolidated, uniform API for animations, to be triggered by other APIs like the `animate` prop, or the gesture handlers.\n *\n * @internal\n */\n\n\nfunction useVisualElementAnimation(visualElement, props, config) {\n  var subscribeToParentControls = checkShouldInheritVariant(props);\n  var variants = props.variants,\n      transition = props.transition;\n  var parentControls = useContext(MotionContext).controls;\n  var presenceContext = useContext(PresenceContext);\n  var controls = useConstant(function () {\n    return new VisualElementAnimationControls(visualElement, config);\n  }); // Reset and resubscribe children every render to ensure stagger order is correct\n\n  if (!presenceContext || presenceContext.isPresent) {\n    controls.resetChildren();\n    controls.setProps(props);\n    controls.setVariants(variants);\n    controls.setDefaultTransition(transition);\n  } // We have to subscribe to the parent controls within a useEffect rather than during render,\n  // as\n\n\n  useEffect(function () {\n    if (subscribeToParentControls && parentControls) {\n      parentControls.addChild(controls);\n    }\n  });\n  useEffect(function () {\n    return function () {\n      // Remove reference to onAnimationComplete from controls. All the MotionValues\n      // are unsubscribed from this component separately. We let animations run out\n      // as they might be animating other components.\n      var onAnimationComplete = props.onAnimationComplete,\n          unmountProps = __rest(props, [\"onAnimationComplete\"]);\n\n      controls.setProps(unmountProps);\n      parentControls && parentControls.removeChild(controls);\n    };\n  }, []);\n  return controls;\n}\n/**\n * @internal\n */\n\n\nvar MotionPluginContext = createContext({\n  transformPagePoint: function transformPagePoint(p) {\n    return p;\n  },\n  features: []\n});\n/**\n * @remarks For now I think this should remain a private API for our own use\n * until we can figure out a nicer way of allowing people to add these\n *\n * @internal\n */\n\nfunction MotionPlugins(_a) {\n  var children = _a.children,\n      props = __rest(_a, [\"children\"]);\n\n  var pluginContext = useContext(MotionPluginContext);\n  var value = useRef(__assign({}, pluginContext)).current; // Mutative to prevent triggering rerenders in all listening\n  // components every time this component renders\n\n  for (var key in props) {\n    value[key] = props[key];\n  }\n\n  return createElement(MotionPluginContext.Provider, {\n    value: value\n  }, children);\n}\n\nfunction createLock(name) {\n  var lock = null;\n  return function () {\n    var openLock = function openLock() {\n      lock = null;\n    };\n\n    if (lock === null) {\n      lock = name;\n      return openLock;\n    }\n\n    return false;\n  };\n}\n\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\n\nfunction getGlobalLock(drag) {\n  var lock = false;\n\n  if (drag === \"y\") {\n    lock = globalVerticalLock();\n  } else if (drag === \"x\") {\n    lock = globalHorizontalLock();\n  } else {\n    var openHorizontal_1 = globalHorizontalLock();\n    var openVertical_1 = globalVerticalLock();\n\n    if (openHorizontal_1 && openVertical_1) {\n      lock = function lock() {\n        openHorizontal_1();\n        openVertical_1();\n      };\n    } else {\n      // Release the locks because we don't use them\n      if (openHorizontal_1) openHorizontal_1();\n      if (openVertical_1) openVertical_1();\n    }\n  }\n\n  return lock;\n}\n\nvar isViewportScrollBlocked = false;\nvar isBrowser = typeof window !== \"undefined\";\n\nif (isBrowser) {\n  document.addEventListener(\"touchmove\", function (event) {\n    if (isViewportScrollBlocked) {\n      event.preventDefault();\n    }\n  }, {\n    passive: false\n  });\n}\n\nvar blockViewportScroll = function blockViewportScroll() {\n  return isViewportScrollBlocked = true;\n};\n\nvar unblockViewportScroll = function unblockViewportScroll() {\n  return isViewportScrollBlocked = false;\n};\n\nfunction addDomEvent(target, eventName, handler, options) {\n  if (!handler) return;\n  target.addEventListener(eventName, handler, options);\n  return function () {\n    return target.removeEventListener(eventName, handler, options);\n  };\n}\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */\n\n\nfunction useDomEvent(ref, eventName, handler, options) {\n  useEffect(function () {\n    var element = ref.current;\n\n    if (handler && element) {\n      return addDomEvent(element, eventName, handler, options);\n    }\n  }, [ref, eventName, handler, options]);\n}\n\nfunction isMouseEvent(event) {\n  // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\n  if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n    return !!(event.pointerType === \"mouse\");\n  }\n\n  return event instanceof MouseEvent;\n}\n\nfunction isTouchEvent(event) {\n  var hasTouches = !!event.touches;\n  return hasTouches;\n}\n/**\n * Filters out events not attached to the primary pointer (currently left mouse button)\n * @param eventHandler\n */\n\n\nfunction filterPrimaryPointer(eventHandler) {\n  if (!eventHandler) return undefined;\n  return function (event) {\n    var isMouseEvent = event instanceof MouseEvent;\n    var isPrimaryPointer = !isMouseEvent || isMouseEvent && event.button === 0;\n\n    if (isPrimaryPointer) {\n      eventHandler(event);\n    }\n  };\n}\n\nvar defaultPagePoint = {\n  pageX: 0,\n  pageY: 0\n};\n\nfunction pointFromTouch(e, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n\n  var primaryTouch = e.touches[0] || e.changedTouches[0];\n  var point = primaryTouch || defaultPagePoint;\n  return {\n    x: point[pointType + \"X\"],\n    y: point[pointType + \"Y\"]\n  };\n}\n\nfunction pointFromMouse(point, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n\n  return {\n    x: point[pointType + \"X\"],\n    y: point[pointType + \"Y\"]\n  };\n}\n\nfunction extractEventInfo(event, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n\n  return {\n    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)\n  };\n}\n\nfunction getViewportPointFromEvent(event) {\n  return extractEventInfo(event, \"client\");\n}\n\nvar wrapHandler = function wrapHandler(handler, shouldFilterPrimaryPointer) {\n  if (shouldFilterPrimaryPointer === void 0) {\n    shouldFilterPrimaryPointer = false;\n  }\n\n  if (!handler) return;\n\n  var listener = function listener(event) {\n    return handler(event, extractEventInfo(event));\n  };\n\n  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;\n};\n\nvar isBrowser$1 = typeof window !== \"undefined\"; // We check for event support via functions in case they've been mocked by a testing suite.\n\nvar supportsPointerEvents = function supportsPointerEvents() {\n  return isBrowser$1 && window.onpointerdown === null;\n};\n\nvar supportsTouchEvents = function supportsTouchEvents() {\n  return isBrowser$1 && window.ontouchstart === null;\n};\n\nvar supportsMouseEvents = function supportsMouseEvents() {\n  return isBrowser$1 && window.onmousedown === null;\n};\n\nvar mouseEventNames = {\n  pointerdown: \"mousedown\",\n  pointermove: \"mousemove\",\n  pointerup: \"mouseup\",\n  pointercancel: \"mousecancel\",\n  pointerover: \"mouseover\",\n  pointerout: \"mouseout\",\n  pointerenter: \"mouseenter\",\n  pointerleave: \"mouseleave\"\n};\nvar touchEventNames = {\n  pointerdown: \"touchstart\",\n  pointermove: \"touchmove\",\n  pointerup: \"touchend\",\n  pointercancel: \"touchcancel\"\n};\n\nfunction getPointerEventName(name) {\n  if (supportsPointerEvents()) {\n    return name;\n  } else if (supportsTouchEvents()) {\n    return touchEventNames[name];\n  } else if (supportsMouseEvents()) {\n    return mouseEventNames[name];\n  }\n\n  return name;\n}\n\nfunction addPointerEvent(target, eventName, handler, options) {\n  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\nfunction usePointerEvent(ref, eventName, handler, options) {\n  return useDomEvent(ref, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n/** @public */\n\n\nvar Point;\n\n(function (Point) {\n  /** @beta */\n  Point.subtract = function (a, b) {\n    return {\n      x: a.x - b.x,\n      y: a.y - b.y\n    };\n  };\n  /** @beta */\n\n\n  Point.relativeTo = function (idOrElem) {\n    var elem;\n\n    var getElem = function getElem() {\n      // Caching element here could be leaky because of React lifecycle\n      if (elem !== undefined) return elem;\n\n      if (typeof idOrElem === \"string\") {\n        elem = document.getElementById(idOrElem);\n      } else {\n        elem = idOrElem;\n      }\n\n      return elem;\n    };\n\n    return function (_a) {\n      var x = _a.x,\n          y = _a.y;\n      var localElem = getElem();\n      if (!localElem) return undefined;\n      var rect = localElem.getBoundingClientRect();\n      return {\n        x: x - rect.left - window.scrollX,\n        y: y - rect.top - window.scrollY\n      };\n    };\n  };\n})(Point || (Point = {}));\n/**\n * @internal\n */\n\n\nvar PanSession =\n/** @class */\nfunction () {\n  function PanSession(event, handlers, _a) {\n    var _this = this;\n\n    var transformPagePoint = (_a === void 0 ? {} : _a).transformPagePoint;\n    /**\n     * @internal\n     */\n\n    this.startEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEventInfo = null;\n    /**\n     * @internal\n     */\n\n    this.handlers = {};\n\n    this.updatePoint = function () {\n      if (!(_this.lastMoveEvent && _this.lastMoveEventInfo)) return;\n      var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n      var isPanStarted = _this.startEvent !== null; // Only start panning if the offset is larger than 3 pixels. If we make it\n      // any larger than this we'll want to reset the pointer history\n      // on the first update to avoid visual snapping to the cursoe.\n\n      var isDistancePastThreshold = distance(info.offset, {\n        x: 0,\n        y: 0\n      }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      var point = info.point;\n      var timestamp = getFrameData().timestamp;\n\n      _this.history.push(__assign(__assign({}, point), {\n        timestamp: timestamp\n      }));\n\n      var _a = _this.handlers,\n          onStart = _a.onStart,\n          onMove = _a.onMove;\n\n      if (!isPanStarted) {\n        onStart && onStart(_this.lastMoveEvent, info);\n        _this.startEvent = _this.lastMoveEvent;\n      }\n\n      onMove && onMove(_this.lastMoveEvent, info);\n    }; // If we have more than one touch, don't start detecting this gesture\n\n\n    if (isTouchEvent(event) && event.touches.length > 1) return;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    var info = extractEventInfo(event);\n    var initialInfo = transformPoint(info, this.transformPagePoint);\n    var point = initialInfo.point;\n    var timestamp = getFrameData().timestamp;\n    this.history = [__assign(__assign({}, point), {\n      timestamp: timestamp\n    })];\n    var onSessionStart = handlers.onSessionStart;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    var removeOnPointerMove = addPointerEvent(window, \"pointermove\", function (event, info) {\n      return _this.handlePointerMove(event, info);\n    });\n    var removeOnPointerUp = addPointerEvent(window, \"pointerup\", function (event, info) {\n      return _this.handlePointerUp(event, info);\n    });\n\n    this.removeListeners = function () {\n      removeOnPointerMove && removeOnPointerMove();\n      removeOnPointerUp && removeOnPointerUp();\n    };\n  }\n\n  PanSession.prototype.handlePointerMove = function (event, info) {\n    this.lastMoveEvent = event;\n    this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint); // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n\n    if (isMouseEvent(event) && event.buttons === 0) {\n      this.handlePointerUp(event, info);\n      return;\n    } // Throttle mouse move event to once per frame\n\n\n    sync.update(this.updatePoint, true);\n  };\n\n  PanSession.prototype.handlePointerUp = function (event, info) {\n    this.end();\n    var onEnd = this.handlers.onEnd;\n    if (!onEnd) return;\n    var panInfo = getPanInfo(transformPoint(info, this.transformPagePoint), this.history);\n    onEnd && onEnd(event, panInfo);\n  };\n\n  PanSession.prototype.updateHandlers = function (handlers) {\n    this.handlers = handlers;\n  };\n\n  PanSession.prototype.end = function () {\n    this.removeListeners && this.removeListeners();\n    cancelSync.update(this.updatePoint);\n    unblockViewportScroll();\n  };\n\n  return PanSession;\n}();\n\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? {\n    point: transformPagePoint(info.point)\n  } : info;\n}\n\nfunction getPanInfo(_a, history) {\n  var point = _a.point;\n  return {\n    point: point,\n    delta: Point.subtract(point, lastDevicePoint(history)),\n    offset: Point.subtract(point, startDevicePoint(history)),\n    velocity: getVelocity$1(history, 0.1)\n  };\n}\n\nfunction startDevicePoint(history) {\n  return history[0];\n}\n\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\n\nfunction getVelocity$1(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var i = history.length - 1;\n  var timestampedPoint = null;\n  var lastPoint = lastDevicePoint(history);\n\n  while (i >= 0) {\n    timestampedPoint = history[i];\n\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n\n    i--;\n  }\n\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n\n  return currentVelocity;\n}\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\n\n\nfunction applyConstraints(point, _a, elastic) {\n  var min = _a.min,\n      max = _a.max;\n\n  if (min !== undefined && point < min) {\n    // If we have a min point defined, and this is outside of that, constrain\n    point = elastic ? mix(min, point, elastic) : Math.max(point, min);\n  } else if (max !== undefined && point > max) {\n    // If we have a max point defined, and this is outside of that, constrain\n    point = elastic ? mix(max, point, elastic) : Math.min(point, max);\n  }\n\n  return point;\n}\n/**\n * Calculates a min projection point based on a pointer, pointer progress\n * within the drag target, and constraints.\n *\n * For instance if an element was 100px width, we were dragging from 0.25\n * along this axis, the pointer is at 200px, and there were no constraints,\n * we would calculate a min projection point of 175px.\n */\n\n\nfunction calcConstrainedMinPoint(point, length, progress, constraints, elastic) {\n  // Calculate a min point for this axis and apply it to the current pointer\n  var min = point - length * progress;\n  return constraints ? applyConstraints(min, constraints, elastic) : min;\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured axis.\n */\n\n\nfunction calcRelativeAxisConstraints(axis, min, max) {\n  var constraints = {};\n  var length = axis.max - axis.min;\n\n  if (min !== undefined) {\n    constraints.min = axis.min + min;\n  }\n\n  if (max !== undefined) {\n    constraints.max = Math.max(axis.min + max - length, axis.min + max);\n  }\n\n  return constraints;\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\n\n\nfunction calcRelativeConstraints(layoutBox, _a) {\n  var top = _a.top,\n      left = _a.left,\n      bottom = _a.bottom,\n      right = _a.right;\n  return {\n    x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\n\n\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n  var _a;\n\n  var min = constraintsAxis.min - layoutAxis.min;\n  var max = constraintsAxis.max - layoutAxis.max; // If the constraints axis is actually smaller than the layout axis then we can\n  // flip the constraints\n\n  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n    _a = [max, min], min = _a[0], max = _a[1];\n  }\n\n  return {\n    min: layoutAxis.min + min,\n    max: layoutAxis.min + max\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\n\n\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n  return {\n    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n  };\n}\n/**\n * Calculate the an axis position based on two axes and a progress value.\n */\n\n\nfunction calcPositionFromProgress(axis, constraints, progress) {\n  var axisLength = axis.max - axis.min;\n  var min = mix(constraints.min, constraints.max - axisLength, progress);\n  return {\n    min: min,\n    max: min + axisLength\n  };\n}\n\nvar elementDragControls = new WeakMap();\n/**\n *\n */\n\nvar lastPointerEvent;\n\nvar VisualElementDragControls =\n/** @class */\nfunction () {\n  function VisualElementDragControls(_a) {\n    var visualElement = _a.visualElement;\n    /**\n     * Track whether we're currently dragging.\n     *\n     * @internal\n     */\n\n    this.isDragging = false;\n    /**\n     * The current direction of drag, or `null` if both.\n     *\n     * @internal\n     */\n\n    this.currentDirection = null;\n    /**\n     * The permitted boundaries of travel, in pixels.\n     *\n     * @internal\n     */\n\n    this.constraints = false;\n    /**\n     * A reference to the host component's latest props.\n     *\n     * @internal\n     */\n\n    this.props = {};\n    /**\n     * Track the initial position of the cursor relative to the dragging element\n     * when dragging starts as a value of 0-1 on each axis. We then use this to calculate\n     * an ideal bounding box for the VisualElement renderer to project into every frame.\n     *\n     * @internal\n     */\n\n    this.cursorProgress = {\n      x: 0.5,\n      y: 0.5\n    }; // This is a reference to the global drag gesture lock, ensuring only one component\n    // can \"capture\" the drag of one or both axes.\n    // TODO: Look into moving this into pansession?\n\n    this.openGlobalLock = null;\n    /**\n     * @internal\n     */\n\n    this.panSession = null;\n    this.visualElement = visualElement;\n    this.visualElement.enableLayoutProjection();\n    elementDragControls.set(visualElement, this);\n  }\n  /**\n   * Instantiate a PanSession for the drag gesture\n   *\n   * @public\n   */\n\n\n  VisualElementDragControls.prototype.start = function (originEvent, _a) {\n    var _this = this;\n\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.snapToCursor,\n        snapToCursor = _c === void 0 ? false : _c,\n        cursorProgress = _b.cursorProgress;\n    /**\n     * If this drag session has been manually triggered by the user, it might be from an event\n     * outside the draggable element. If snapToCursor is set to true, we need to measure the position\n     * of the element and snap it to the cursor.\n     */\n\n\n    snapToCursor && this.snapToCursor(originEvent);\n\n    var onSessionStart = function onSessionStart() {\n      // Initiate viewport scroll blocking on touch start. This is a very aggressive approach\n      // which has come out of the difficulty in us being able to do this once a scroll gesture\n      // has initiated in mobile browsers. This means if there's a horizontally-scrolling carousel\n      // on a page we can't let a user scroll the page itself from it. Ideally what we'd do is\n      // trigger this once we've got a scroll direction determined. This approach sort-of worked\n      // but if the component was dragged too far in a single frame page scrolling would initiate.\n      blockViewportScroll(); // Stop any animations on both axis values immediately. This allows the user to throw and catch\n      // the component.\n\n      _this.stopMotion();\n    };\n\n    var onStart = function onStart(event, info) {\n      var _a, _b; // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n\n\n      var _c = _this.props,\n          drag = _c.drag,\n          dragPropagation = _c.dragPropagation;\n\n      if (drag && !dragPropagation) {\n        if (_this.openGlobalLock) _this.openGlobalLock();\n        _this.openGlobalLock = getGlobalLock(drag); // If we don 't have the lock, don't start dragging\n\n        if (!_this.openGlobalLock) return;\n      }\n      /**\n       * Record the progress of the mouse within the draggable element on each axis.\n       * onPan, we're going to use this to calculate a new bounding box for the element to\n       * project into. This will ensure that even if the DOM element moves via a relayout, it'll\n       * stick to the correct place under the pointer.\n       */\n\n\n      _this.prepareBoundingBox();\n\n      _this.visualElement.lockTargetBox();\n      /**\n       * Resolve the drag constraints. These are either set as top/right/bottom/left constraints\n       * relative to the element's layout, or a ref to another element. Both need converting to\n       * viewport coordinates.\n       */\n\n\n      _this.resolveDragConstraints();\n      /**\n       * When dragging starts, we want to find where the cursor is relative to the bounding box\n       * of the element. Every frame, we calculate a new bounding box using this relative position\n       * and let the visualElement renderer figure out how to reproject the element into this bounding\n       * box.\n       *\n       * By doing it this way, rather than applying an x/y transform directly to the element,\n       * we can ensure the component always visually sticks to the cursor as we'd expect, even\n       * if the DOM element itself changes layout as a result of React updates the user might\n       * make based on the drag position.\n       */\n\n\n      var point = getViewportPointFromEvent(event).point;\n      eachAxis(function (axis) {\n        var _a = _this.visualElement.targetBox[axis],\n            min = _a.min,\n            max = _a.max;\n        _this.cursorProgress[axis] = cursorProgress ? cursorProgress[axis] : progress(min, max, point[axis]);\n      }); // Set current drag status\n\n      _this.isDragging = true;\n      _this.currentDirection = null; // Fire onDragStart event\n\n      (_b = (_a = _this.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\n    };\n\n    var onMove = function onMove(event, info) {\n      var _a, _b, _c, _d;\n\n      var _e = _this.props,\n          dragPropagation = _e.dragPropagation,\n          dragDirectionLock = _e.dragDirectionLock; // If we didn't successfully receive the gesture lock, early return.\n\n      if (!dragPropagation && !_this.openGlobalLock) return;\n      var offset = info.offset; // Attempt to detect drag direction if directionLock is true\n\n      if (dragDirectionLock && _this.currentDirection === null) {\n        _this.currentDirection = getCurrentDirection(offset); // If we've successfully set a direction, notify listener\n\n        if (_this.currentDirection !== null) {\n          (_b = (_a = _this.props).onDirectionLock) === null || _b === void 0 ? void 0 : _b.call(_a, _this.currentDirection);\n        }\n\n        return;\n      } // Update each point with the latest position\n\n\n      _this.updateAxis(\"x\", event);\n\n      _this.updateAxis(\"y\", event); // Fire onDrag event\n\n\n      (_d = (_c = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c, event, info); // Update the last pointer event\n\n      lastPointerEvent = event;\n    };\n\n    var onEnd = function onEnd(event, info) {\n      return _this.stop(event, info);\n    };\n\n    var transformPagePoint = this.props.transformPagePoint;\n    this.panSession = new PanSession(originEvent, {\n      onSessionStart: onSessionStart,\n      onStart: onStart,\n      onMove: onMove,\n      onEnd: onEnd\n    }, {\n      transformPagePoint: transformPagePoint\n    });\n  };\n  /**\n   * Ensure the component's layout and target bounding boxes are up-to-date.\n   */\n\n\n  VisualElementDragControls.prototype.prepareBoundingBox = function () {\n    var element = this.visualElement.getInstance();\n    var transform = element.style.transform;\n    this.visualElement.resetTransform();\n    this.visualElement.measureLayout();\n    element.style.transform = transform;\n    this.visualElement.refreshTargetBox();\n  };\n\n  VisualElementDragControls.prototype.resolveDragConstraints = function () {\n    var dragConstraints = this.props.dragConstraints;\n\n    if (dragConstraints) {\n      this.constraints = isRefObject(dragConstraints) ? this.resolveRefConstraints(this.visualElement.box, dragConstraints) : calcRelativeConstraints(this.visualElement.box, dragConstraints);\n    } else {\n      this.constraints = false;\n    }\n  };\n\n  VisualElementDragControls.prototype.resolveRefConstraints = function (layoutBox, constraints) {\n    var _a = this.props,\n        onMeasureDragConstraints = _a.onMeasureDragConstraints,\n        transformPagePoint = _a.transformPagePoint;\n    var constraintsElement = constraints.current;\n    invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n    this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);\n    var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);\n    /**\n     * If there's an onMeasureDragConstraints listener we call it and\n     * if different constraints are returned, set constraints to that\n     */\n\n    if (onMeasureDragConstraints) {\n      var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));\n\n      if (userConstraints) {\n        measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);\n      }\n    }\n\n    return measuredConstraints;\n  };\n\n  VisualElementDragControls.prototype.cancelDrag = function () {\n    unblockViewportScroll();\n    this.isDragging = false;\n    this.panSession && this.panSession.end();\n    this.panSession = null;\n\n    if (!this.props.dragPropagation && this.openGlobalLock) {\n      this.openGlobalLock();\n      this.openGlobalLock = null;\n    }\n  };\n\n  VisualElementDragControls.prototype.stop = function (event, info) {\n    var _a;\n\n    this.visualElement.unlockTargetBox();\n    (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n    this.panSession = null;\n    var isDragging = this.isDragging;\n    this.cancelDrag();\n    if (!isDragging) return;\n    var _b = this.props,\n        dragMomentum = _b.dragMomentum,\n        dragElastic = _b.dragElastic,\n        onDragEnd = _b.onDragEnd;\n\n    if (dragMomentum || dragElastic) {\n      var velocity = info.velocity;\n      this.animateDragEnd(velocity);\n    }\n\n    onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);\n  };\n\n  VisualElementDragControls.prototype.snapToCursor = function (event) {\n    this.prepareBoundingBox();\n    this.cursorProgress.x = 0.5;\n    this.cursorProgress.y = 0.5;\n    this.updateAxis(\"x\", event);\n    this.updateAxis(\"y\", event);\n  };\n  /**\n   * Update the specified axis with the latest pointer information.\n   */\n\n\n  VisualElementDragControls.prototype.updateAxis = function (axis, event) {\n    var _a;\n\n    var _b = this.props,\n        drag = _b.drag,\n        dragElastic = _b.dragElastic; // If we're not dragging this axis, do an early return.\n\n    if (!shouldDrag(axis, drag, this.currentDirection)) return; // Get the actual layout bounding box of the element\n\n    var axisLayout = this.visualElement.box[axis]; // Calculate its current length. In the future we might want to lerp this to animate\n    // between lengths if the layout changes as we change the DOM\n\n    var axisLength = axisLayout.max - axisLayout.min; // Get the initial progress that the pointer sat on this axis on gesture start.\n\n    var axisProgress = this.cursorProgress[axis];\n    var point = getViewportPointFromEvent(event).point; // Calculate a new min point based on the latest pointer position, constraints and elastic\n\n    var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], dragElastic); // Update the axis viewport target with this new min and the length\n\n    this.visualElement.setAxisTarget(axis, min, min + axisLength);\n  };\n\n  VisualElementDragControls.prototype.updateProps = function (_a) {\n    var _b = _a.drag,\n        drag = _b === void 0 ? false : _b,\n        _c = _a.dragDirectionLock,\n        dragDirectionLock = _c === void 0 ? false : _c,\n        _d = _a.dragPropagation,\n        dragPropagation = _d === void 0 ? false : _d,\n        _e = _a.dragConstraints,\n        dragConstraints = _e === void 0 ? false : _e,\n        _f = _a.dragElastic,\n        dragElastic = _f === void 0 ? 0.35 : _f,\n        _g = _a.dragMomentum,\n        dragMomentum = _g === void 0 ? true : _g,\n        remainingProps = __rest(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\n\n    this.props = __assign({\n      drag: drag,\n      dragDirectionLock: dragDirectionLock,\n      dragPropagation: dragPropagation,\n      dragConstraints: dragConstraints,\n      dragElastic: dragElastic,\n      dragMomentum: dragMomentum\n    }, remainingProps);\n  };\n\n  VisualElementDragControls.prototype.animateDragEnd = function (velocity) {\n    var _this = this;\n\n    var _a = this.props,\n        drag = _a.drag,\n        dragMomentum = _a.dragMomentum,\n        dragElastic = _a.dragElastic,\n        dragTransition = _a.dragTransition;\n    var momentumAnimations = eachAxis(function (axis) {\n      if (!shouldDrag(axis, drag, _this.currentDirection)) {\n        return;\n      }\n\n      var transition = _this.constraints ? _this.constraints[axis] : {};\n      /**\n       * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n       * of spring animations so we should look into adding a disable spring option to `inertia`.\n       * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n       * using the value of `dragElastic`.\n       */\n\n      var bounceStiffness = dragElastic ? 200 : 1000000;\n      var bounceDamping = dragElastic ? 40 : 10000000;\n\n      var inertia = __assign(__assign({\n        type: \"inertia\",\n        velocity: dragMomentum ? velocity[axis] : 0,\n        bounceStiffness: bounceStiffness,\n        bounceDamping: bounceDamping,\n        timeConstant: 750,\n        restDelta: 1,\n        restSpeed: 10\n      }, dragTransition), transition); // If we're not animating on an externally-provided `MotionValue` we can use the\n      // component's animation controls which will handle interactions with whileHover (etc),\n      // otherwise we just have to animate the `MotionValue` itself.\n\n\n      return _this.visualElement.startLayoutAxisAnimation(axis, inertia);\n    }); // Run all animations and then resolve the new drag constraints.\n\n    return Promise.all(momentumAnimations).then(function () {\n      var _a, _b;\n\n      (_b = (_a = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n    });\n  };\n\n  VisualElementDragControls.prototype.stopMotion = function () {\n    this.visualElement.stopLayoutAnimation();\n  };\n\n  VisualElementDragControls.prototype.scalePoint = function () {\n    var _this = this;\n\n    var _a = this.props,\n        drag = _a.drag,\n        dragConstraints = _a.dragConstraints;\n    if (!isRefObject(dragConstraints) || !this.constraintsBox) return; // Stop any current animations as there can be some visual glitching if we resize mid animation\n\n    this.stopMotion(); // Record the relative progress of the targetBox relative to the constraintsBox\n\n    var boxProgress = {\n      x: 0,\n      y: 0\n    };\n    eachAxis(function (axis) {\n      boxProgress[axis] = calcOrigin(_this.visualElement.targetBox[axis], _this.constraintsBox[axis]);\n    });\n    /**\n     * For each axis, calculate the current progress of the layout axis within the constraints.\n     * Then, using the latest layout and constraints measurements, reposition the new layout axis\n     * proportionally within the constraints.\n     */\n\n    this.prepareBoundingBox();\n    this.resolveDragConstraints();\n    eachAxis(function (axis) {\n      if (!shouldDrag(axis, drag, null)) return; // Calculate the position of the targetBox relative to the constraintsBox using the\n      // previously calculated progress\n\n      var _a = calcPositionFromProgress(_this.visualElement.targetBox[axis], _this.constraintsBox[axis], boxProgress[axis]),\n          min = _a.min,\n          max = _a.max;\n\n      _this.visualElement.setAxisTarget(axis, min, max);\n    });\n  };\n\n  VisualElementDragControls.prototype.mount = function (visualElement) {\n    var _this = this;\n\n    var element = visualElement.getInstance();\n    /**\n     * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n     */\n\n    var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\n      var _a = _this.props,\n          drag = _a.drag,\n          _b = _a.dragListener,\n          dragListener = _b === void 0 ? true : _b;\n      drag && dragListener && _this.start(event);\n    });\n    /**\n     * Attach a window resize listener to scale the draggable target within its defined\n     * constraints as the window resizes.\n     */\n\n    var stopResizeListener = addDomEvent(window, \"resize\", function () {\n      _this.scalePoint();\n    });\n    /**\n     * Ensure drag constraints are resolved correctly relative to the dragging element\n     * whenever its layout changes.\n     */\n\n    var stopLayoutUpdateListener = visualElement.onLayoutUpdate(function () {\n      if (_this.isDragging) _this.resolveDragConstraints();\n    });\n    /**\n     * If the previous component with this same layoutId was dragging at the time\n     * it was unmounted, we want to continue the same gesture on this component.\n     */\n\n    var prevSnapshot = visualElement.prevSnapshot;\n    (prevSnapshot === null || prevSnapshot === void 0 ? void 0 : prevSnapshot.isDragging) && this.start(lastPointerEvent, {\n      cursorProgress: prevSnapshot.cursorProgress\n    });\n    /**\n     * Return a function that will teardown the drag gesture\n     */\n\n    return function () {\n      stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();\n      stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();\n      stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\n\n      _this.cancelDrag();\n    };\n  };\n\n  return VisualElementDragControls;\n}();\n\nfunction shouldDrag(direction, drag, currentDirection) {\n  return (drag === true || drag === direction) && (currentDirection === null || currentDirection === direction);\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\n\n\nfunction getCurrentDirection(offset, lockThreshold) {\n  if (lockThreshold === void 0) {\n    lockThreshold = 10;\n  }\n\n  var direction = null;\n\n  if (Math.abs(offset.y) > lockThreshold) {\n    direction = \"y\";\n  } else if (Math.abs(offset.x) > lockThreshold) {\n    direction = \"x\";\n  }\n\n  return direction;\n}\n/**\n * A hook that allows an element to be dragged.\n *\n * @internal\n */\n\n\nfunction useDrag(props, visualElement) {\n  var groupDragControls = props.dragControls;\n  var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\n  var dragControls = useConstant(function () {\n    return new VisualElementDragControls({\n      visualElement: visualElement\n    });\n  });\n  dragControls.updateProps(__assign(__assign({}, props), {\n    transformPagePoint: transformPagePoint\n  })); // If we've been provided a DragControls for manual control over the drag gesture,\n  // subscribe this component to it on mount.\n\n  useEffect(function () {\n    return groupDragControls && groupDragControls.subscribe(dragControls);\n  }, [dragControls]); // Mount the drag controls with the visualElement\n\n  useEffect(function () {\n    return dragControls.mount(visualElement);\n  }, []);\n}\n\nvar makeRenderlessComponent = function makeRenderlessComponent(hook) {\n  return function (props) {\n    hook(props);\n    return null;\n  };\n};\n\nvar Drag = {\n  key: \"drag\",\n  shouldRender: function shouldRender(props) {\n    return !!props.drag;\n  },\n  Component: makeRenderlessComponent(function (_a) {\n    var visualElement = _a.visualElement,\n        props = __rest(_a, [\"visualElement\"]);\n\n    return useDrag(props, visualElement);\n  })\n};\n\nfunction useUnmountEffect(callback) {\n  return useEffect(function () {\n    return function () {\n      return callback();\n    };\n  }, []);\n}\n/**\n *\n * @param handlers -\n * @param ref -\n *\n * @internalremarks\n * Currently this sets new pan gesture functions every render. The memo route has been explored\n * in the past but ultimately we're still creating new functions every render. An optimisation\n * to explore is creating the pan gestures and loading them into a `ref`.\n *\n * @internal\n */\n\n\nfunction usePanGesture(_a, ref) {\n  var onPan = _a.onPan,\n      onPanStart = _a.onPanStart,\n      onPanEnd = _a.onPanEnd,\n      onPanSessionStart = _a.onPanSessionStart;\n  var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n  var panSession = useRef(null);\n  var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\n  var handlers = {\n    onSessionStart: onPanSessionStart,\n    onStart: onPanStart,\n    onMove: onPan,\n    onEnd: function onEnd(event, info) {\n      panSession.current = null;\n      onPanEnd && onPanEnd(event, info);\n    }\n  };\n  useEffect(function () {\n    if (panSession.current !== null) {\n      panSession.current.updateHandlers(handlers);\n    }\n  });\n\n  function onPointerDown(event) {\n    panSession.current = new PanSession(event, handlers, {\n      transformPagePoint: transformPagePoint\n    });\n  }\n\n  usePointerEvent(ref, \"pointerdown\", hasPanEvents && onPointerDown);\n  useUnmountEffect(function () {\n    return panSession.current && panSession.current.end();\n  });\n}\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\n\n\nvar isNodeOrChild = function isNodeOrChild(parent, child) {\n  if (!child) {\n    return false;\n  } else if (parent === child) {\n    return true;\n  } else {\n    return isNodeOrChild(parent, child.parentElement);\n  }\n};\n\nvar order$1 = [\"whileHover\", \"whileTap\", \"whileDrag\"];\n\nvar getGesturePriority = function getGesturePriority(gesture) {\n  return order$1.indexOf(gesture) + 1;\n};\n\nvar tapGesturePriority = getGesturePriority(\"whileTap\");\n/**\n * @param handlers -\n * @internal\n */\n\nfunction useTapGesture(_a, ref) {\n  var onTap = _a.onTap,\n      onTapStart = _a.onTapStart,\n      onTapCancel = _a.onTapCancel,\n      whileTap = _a.whileTap,\n      controls = _a.controls;\n  var hasTapListeners = onTap || onTapStart || onTapCancel || whileTap;\n  var isTapping = useRef(false);\n  var cancelPointerEventListener = useRef(null);\n\n  function removePointerUp() {\n    cancelPointerEventListener.current && cancelPointerEventListener.current();\n    cancelPointerEventListener.current = null;\n  }\n\n  if (whileTap && controls) {\n    controls.setOverride(whileTap, tapGesturePriority);\n  } // We load this event handler into a ref so we can later refer to\n  // onPointerUp.current which will always have reference to the latest props\n\n\n  var onPointerUp = useRef(null);\n\n  onPointerUp.current = function (event, info) {\n    var element = ref.current;\n    removePointerUp();\n    if (!isTapping.current || !element) return;\n    isTapping.current = false;\n\n    if (controls && whileTap) {\n      controls.clearOverride(tapGesturePriority);\n    } // Check the gesture lock - if we get it, it means no drag gesture is active\n    // and we can safely fire the tap gesture.\n\n\n    var openGestureLock = getGlobalLock(true);\n    if (!openGestureLock) return;\n    openGestureLock();\n\n    if (!isNodeOrChild(element, event.target)) {\n      onTapCancel && onTapCancel(event, info);\n    } else {\n      onTap && onTap(event, info);\n    }\n  };\n\n  function onPointerDown(event, info) {\n    removePointerUp();\n    cancelPointerEventListener.current = addPointerEvent(window, \"pointerup\", function (event, info) {\n      return onPointerUp.current(event, info);\n    });\n    var element = ref.current;\n    if (!element || isTapping.current) return;\n    isTapping.current = true;\n    onTapStart && onTapStart(event, info);\n\n    if (controls && whileTap) {\n      controls.startOverride(tapGesturePriority);\n    }\n  }\n\n  usePointerEvent(ref, \"pointerdown\", hasTapListeners ? onPointerDown : undefined);\n  useUnmountEffect(removePointerUp);\n}\n\nvar hoverPriority = getGesturePriority(\"whileHover\");\n\nvar filterTouch = function filterTouch(listener) {\n  return function (event, info) {\n    if (isMouseEvent(event)) listener(event, info);\n  };\n};\n/**\n *\n * @param props\n * @param ref\n * @internal\n */\n\n\nfunction useHoverGesture(_a, ref) {\n  var whileHover = _a.whileHover,\n      onHoverStart = _a.onHoverStart,\n      onHoverEnd = _a.onHoverEnd,\n      controls = _a.controls;\n\n  if (whileHover && controls) {\n    controls.setOverride(whileHover, hoverPriority);\n  }\n\n  usePointerEvent(ref, \"pointerenter\", filterTouch(function (event, info) {\n    if (onHoverStart) onHoverStart(event, info);\n\n    if (whileHover && controls) {\n      controls.startOverride(hoverPriority);\n    }\n  }));\n  usePointerEvent(ref, \"pointerleave\", filterTouch(function (event, info) {\n    if (onHoverEnd) onHoverEnd(event, info);\n\n    if (whileHover && controls) {\n      controls.clearOverride(hoverPriority);\n    }\n  }));\n}\n/**\n * Add pan and tap gesture recognition to an element.\n *\n * @param props - Gesture event handlers\n * @param ref - React `ref` containing a DOM `Element`\n * @public\n */\n\n\nfunction useGestures(props, ref) {\n  usePanGesture(props, ref);\n  useTapGesture(props, ref);\n  useHoverGesture(props, ref);\n}\n\nvar gestureProps = [\"onPan\", \"onPanStart\", \"onPanEnd\", \"onPanSessionStart\", \"onTap\", \"onTapStart\", \"onTapCancel\", \"whileTap\", \"whileHover\", \"onHoverStart\", \"onHoverEnd\"];\nvar Gestures = {\n  key: \"gestures\",\n  shouldRender: function shouldRender(props) {\n    return gestureProps.some(function (key) {\n      return props.hasOwnProperty(key);\n    });\n  },\n  Component: makeRenderlessComponent(function (_a) {\n    var visualElement = _a.visualElement,\n        props = __rest(_a, [\"visualElement\"]);\n\n    useGestures(props, visualElement);\n  })\n};\nvar Exit = {\n  key: \"exit\",\n  shouldRender: function shouldRender(props) {\n    return !!props.exit && !checkShouldInheritVariant(props);\n  },\n  Component: makeRenderlessComponent(function (props) {\n    var animate = props.animate,\n        controls = props.controls,\n        exit = props.exit;\n\n    var _a = usePresence(),\n        isPresent = _a[0],\n        onExitComplete = _a[1];\n\n    var presenceContext = useContext(PresenceContext);\n    var isPlayingExitAnimation = useRef(false);\n    var custom = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== undefined ? presenceContext.custom : props.custom;\n    useEffect(function () {\n      if (!isPresent) {\n        if (!isPlayingExitAnimation.current && exit) {\n          controls.setProps(__assign(__assign({}, props), {\n            custom: custom\n          }));\n          controls.start(exit).then(onExitComplete);\n        }\n\n        isPlayingExitAnimation.current = true;\n      } else if (isPlayingExitAnimation.current && animate && typeof animate !== \"boolean\" && !(animate instanceof AnimationControls)) {\n        controls.start(animate);\n      }\n\n      if (isPresent) {\n        isPlayingExitAnimation.current = false;\n      }\n    }, [animate, controls, custom, exit, isPresent, onExitComplete, props]);\n  })\n};\nvar AnimatePropType;\n\n(function (AnimatePropType) {\n  AnimatePropType[\"Target\"] = \"Target\";\n  AnimatePropType[\"VariantLabel\"] = \"VariantLabel\";\n  AnimatePropType[\"AnimationSubscription\"] = \"AnimationSubscription\";\n})(AnimatePropType || (AnimatePropType = {}));\n\nfunction shallowCompare(next, prev) {\n  if (prev === null) return false;\n  var prevLength = prev.length;\n  if (prevLength !== next.length) return false;\n\n  for (var i = 0; i < prevLength; i++) {\n    if (prev[i] !== next[i]) return false;\n  }\n\n  return true;\n}\n\nvar hasUpdated = function hasUpdated(prev, next) {\n  return next !== undefined && (Array.isArray(prev) && Array.isArray(next) ? !shallowCompare(next, prev) : prev !== next);\n};\n\nfunction targetWithoutTransition(_a, mergeTransitionEnd) {\n  if (mergeTransitionEnd === void 0) {\n    mergeTransitionEnd = false;\n  }\n\n  var transition = _a.transition,\n      transitionEnd = _a.transitionEnd,\n      target = __rest(_a, [\"transition\", \"transitionEnd\"]);\n\n  return mergeTransitionEnd ? __assign(__assign({}, target), transitionEnd) : target;\n}\n/**\n * Handle the `animate` prop when its an object of values, ie:\n *\n * ```jsx\n * <motion.div animate={{ opacity: 1 }} />\n * ```\n *\n * @internalremarks\n * It might be worth consolidating this with `use-variants`\n *\n * ```jsx\n * <motion.div animate=\"visible\" />\n * ```\n *\n * @param target\n * @param controls\n * @param values\n * @param transition\n *\n * @internal\n */\n\n\nfunction useAnimateProp(targetAndTransition, controls, visualElement, defaultTransition) {\n  var isInitialRender = useRef(true);\n  var prevValues = useRef(null);\n\n  if (!prevValues.current) {\n    prevValues.current = targetWithoutTransition(targetAndTransition, true);\n  }\n\n  useEffect(function () {\n    var targetToAnimate = {}; // These are the values we're actually animating\n\n    var animatingTarget = targetWithoutTransition(targetAndTransition); // This is the target as it'll be once transitionEnd values are applied\n\n    var finalTarget = targetWithoutTransition(targetAndTransition, true); // Detect which values have changed between renders\n\n    for (var key in animatingTarget) {\n      // This value should animate on mount if this value doesn't already exist (wasn't\n      // defined in `style` or `initial`) or if it does exist and it's already changed.\n      var shouldAnimateOnMount = isInitialRender.current && (!visualElement.hasValue(key) || visualElement.getValue(key).get() !== finalTarget[key]); // If this value has updated between renders or it's we're animating this value on mount,\n      // add it to the animate target.\n\n      var isValidValue = finalTarget[key] !== null;\n      var valueHasUpdated = hasUpdated(prevValues.current[key], finalTarget[key]);\n\n      if (isValidValue && (valueHasUpdated || shouldAnimateOnMount)) {\n        targetToAnimate[key] = animatingTarget[key];\n      }\n    }\n\n    isInitialRender.current = false;\n    prevValues.current = __assign(__assign({}, prevValues.current), finalTarget);\n\n    if (Object.keys(targetToAnimate).length) {\n      controls.start(__assign(__assign({}, targetToAnimate), {\n        transition: targetAndTransition.transition || defaultTransition,\n        transitionEnd: targetAndTransition.transitionEnd\n      }));\n    }\n  }, [targetAndTransition]);\n}\n\nvar labelsToArray = function labelsToArray(label) {\n  if (!label) {\n    return [];\n  }\n\n  if (Array.isArray(label)) {\n    return label;\n  }\n\n  return [label];\n};\n\nvar resolveVariantLabels = function resolveVariantLabels(variant) {\n  var unresolvedVariant = variant instanceof MotionValue ? variant.get() : variant;\n  return Array.from(new Set(labelsToArray(unresolvedVariant)));\n};\n/**\n * Hooks in React sometimes accept a dependency array as their final argument. (ie useEffect/useMemo)\n * When values in this array change, React re-runs the dependency. However if the array\n * contains a variable number of items, React throws an error.\n */\n\n\nvar asDependencyList = function asDependencyList(list) {\n  return [list.join(\",\")];\n};\n\nvar hasVariantChanged = function hasVariantChanged(oldVariant, newVariant) {\n  return oldVariant.join(\",\") !== newVariant.join(\",\");\n};\n/**\n * Handle variants and the `animate` prop when its set as variant labels.\n *\n * @param initial - Initial variant(s)\n * @param animate - Variant(s) to animate to\n * @param inherit - `true` is inheriting animations from parent\n * @param controls - Animation controls\n *\n * @internal\n */\n\n\nfunction useVariants(initial, animate, inherit, controls) {\n  var targetVariants = resolveVariantLabels(animate);\n  var context = useContext(MotionContext);\n  var parentAlreadyMounted = context.hasMounted && context.hasMounted.current;\n  var hasMounted = useRef(false);\n  useEffect(function () {\n    var shouldAnimate = false;\n\n    if (inherit) {\n      // If we're inheriting variant changes and the parent has already\n      // mounted when this component loads, we need to manually trigger\n      // this animation.\n      shouldAnimate = !!parentAlreadyMounted;\n      targetVariants = resolveVariantLabels(context.animate);\n    } else {\n      shouldAnimate = hasMounted.current || hasVariantChanged(resolveVariantLabels(initial), targetVariants);\n    }\n\n    shouldAnimate && controls.start(targetVariants);\n    hasMounted.current = true;\n  }, asDependencyList(targetVariants));\n}\n/**\n * `useAnimationGroupSubscription` allows a component to subscribe to an\n * externally-created `AnimationControls`, created by the `useAnimation` hook.\n *\n * @param animation\n * @param controls\n *\n * @internal\n */\n\n\nfunction useAnimationGroupSubscription(animation, controls) {\n  var unsubscribe = useMemo(function () {\n    return animation.subscribe(controls);\n  }, [animation]);\n  useEffect(function () {\n    return function () {\n      unsubscribe && unsubscribe();\n    };\n  }, [unsubscribe]);\n}\n\nvar _a, _b;\n\nvar AnimatePropComponents = (_a = {}, _a[AnimatePropType.Target] = makeRenderlessComponent(function (_a) {\n  var animate = _a.animate,\n      controls = _a.controls,\n      visualElement = _a.visualElement,\n      transition = _a.transition;\n  return useAnimateProp(animate, controls, visualElement, transition);\n}), _a[AnimatePropType.VariantLabel] = makeRenderlessComponent(function (_a) {\n  var animate = _a.animate,\n      _b = _a.inherit,\n      inherit = _b === void 0 ? true : _b,\n      controls = _a.controls,\n      initial = _a.initial;\n  return useVariants(initial, animate, inherit, controls);\n}), _a[AnimatePropType.AnimationSubscription] = makeRenderlessComponent(function (_a) {\n  var animate = _a.animate,\n      controls = _a.controls;\n  return useAnimationGroupSubscription(animate, controls);\n}), _a);\n\nvar isVariantLabel$1 = function isVariantLabel$1(prop) {\n  return Array.isArray(prop) || typeof prop === \"string\";\n};\n\nvar isAnimationSubscription = function isAnimationSubscription(_a) {\n  var animate = _a.animate;\n  return animate instanceof AnimationControls;\n};\n\nvar animationProps = [\"initial\", \"animate\", \"whileTap\", \"whileHover\"];\nvar animatePropTypeTests = (_b = {}, _b[AnimatePropType.Target] = function (props) {\n  return props.animate !== undefined && !isVariantLabel$1(props.animate) && !isAnimationSubscription(props);\n}, _b[AnimatePropType.VariantLabel] = function (props) {\n  return props.variants !== undefined || animationProps.some(function (key) {\n    return typeof props[key] === \"string\";\n  });\n}, _b[AnimatePropType.AnimationSubscription] = isAnimationSubscription, _b);\n\nvar getAnimationComponent = function getAnimationComponent(props) {\n  var animatePropType = undefined;\n\n  for (var key in AnimatePropType) {\n    if (animatePropTypeTests[key](props)) {\n      animatePropType = key;\n    }\n  }\n\n  return animatePropType ? AnimatePropComponents[animatePropType] : undefined;\n};\n\nfunction tweenAxis(target, prev, next, p) {\n  target.min = mix(prev.min, next.min, p);\n  target.max = mix(prev.max, next.max, p);\n}\n\nvar Presence;\n\n(function (Presence) {\n  Presence[Presence[\"Entering\"] = 0] = \"Entering\";\n  Presence[Presence[\"Present\"] = 1] = \"Present\";\n  Presence[Presence[\"Exiting\"] = 2] = \"Exiting\";\n})(Presence || (Presence = {}));\n\nvar VisibilityAction;\n\n(function (VisibilityAction) {\n  VisibilityAction[VisibilityAction[\"Hide\"] = 0] = \"Hide\";\n  VisibilityAction[VisibilityAction[\"Show\"] = 1] = \"Show\";\n})(VisibilityAction || (VisibilityAction = {}));\n\nvar progressTarget = 1000;\n\nvar Animate =\n/** @class */\nfunction (_super) {\n  __extends(Animate, _super);\n\n  function Animate() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.frameTarget = {\n      x: {\n        min: 0,\n        max: 0\n      },\n      y: {\n        min: 0,\n        max: 0\n      }\n    };\n    _this.stopAxisAnimation = {\n      x: undefined,\n      y: undefined\n    };\n\n    _this.animate = function (target, origin, _a) {\n      if (_a === void 0) {\n        _a = {};\n      }\n\n      var originBox = _a.originBox,\n          targetBox = _a.targetBox,\n          visibilityAction = _a.visibilityAction,\n          config = __rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\"]);\n\n      var _b = _this.props,\n          visualElement = _b.visualElement,\n          layout = _b.layout;\n      /**\n       * Allow the measured origin (prev bounding box) and target (actual layout) to be\n       * overridden by the provided config.\n       */\n\n      origin = originBox || origin;\n      target = targetBox || target;\n      var boxHasMoved = hasMoved(origin, target);\n      var animations = eachAxis(function (axis) {\n        /**\n         * If layout is set to \"position\", we can resize the origin box based on the target\n         * box and only animate its position.\n         */\n        if (layout === \"position\") {\n          var targetLength = target[axis].max - target[axis].min;\n          origin[axis].max = origin[axis].min + targetLength;\n        }\n\n        if (visualElement.isTargetBoxLocked) {\n          return;\n        } else if (visibilityAction !== undefined) {\n          // If we're meant to show/hide the visualElement, do so\n          visibilityAction === VisibilityAction.Hide ? visualElement.hide() : visualElement.show();\n        } else if (boxHasMoved) {\n          // If the box has moved, animate between it's current visual state and its\n          // final state\n          return _this.animateAxis(axis, target[axis], origin[axis], config);\n        } else {\n          // If the box has remained in the same place, immediately set the axis target\n          // to the final desired state\n          return visualElement.setAxisTarget(axis, target[axis].min, target[axis].max);\n        }\n      }); // Force a render to ensure there's no flash of uncorrected bounding box.\n\n      visualElement.render();\n      /**\n       * If this visualElement isn't present (ie it's been removed from the tree by the user but\n       * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\n       * have successfully finished.\n       */\n\n      return Promise.all(animations).then(function () {\n        var _a, _b;\n\n        (_a = config.onLayoutAnimationComplete) === null || _a === void 0 ? void 0 : _a.call(config);\n\n        if (visualElement.isPresent) {\n          visualElement.presence = Presence.Present;\n        } else {\n          (_b = config.onLayoutAnimationComplete) === null || _b === void 0 ? void 0 : _b.call(config);\n\n          _this.safeToRemove();\n        }\n      });\n    };\n\n    return _this;\n  }\n\n  Animate.prototype.componentDidMount = function () {\n    var visualElement = this.props.visualElement;\n    visualElement.enableLayoutProjection();\n    this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\n  };\n\n  Animate.prototype.componentWillUnmount = function () {\n    var _this = this;\n\n    this.unsubLayoutReady();\n    eachAxis(function (axis) {\n      var _a, _b;\n\n      return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a);\n    });\n  };\n  /**\n   * TODO: This manually performs animations on the visualElement's layout progress\n   * values. It'd be preferable to amend the HTMLVisualElement.startLayoutAxisAnimation\n   * API to accept more custom animations like this.\n   */\n\n\n  Animate.prototype.animateAxis = function (axis, target, origin, _a) {\n    var _b, _c;\n\n    var _d = _a === void 0 ? {} : _a,\n        transition = _d.transition,\n        crossfadeOpacity = _d.crossfadeOpacity;\n\n    (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\n    var visualElement = this.props.visualElement;\n    var frameTarget = this.frameTarget[axis];\n    var layoutProgress = visualElement.axisProgress[axis];\n    /**\n     * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\n     * be re-incoporated into a subsequent spring animation.\n     */\n\n    layoutProgress.clearListeners();\n    layoutProgress.set(0);\n    layoutProgress.set(0);\n    /**\n     * If this is a crossfade animation, create a function that updates both the opacity of this component\n     * and the one being crossfaded out.\n     */\n\n    var crossfade = crossfadeOpacity && this.createCrossfadeAnimation(crossfadeOpacity);\n    /**\n     * Create an animation function to run once per frame. This will tween the visual bounding box from\n     * origin to target using the latest progress value.\n     */\n\n    var frame = function frame() {\n      // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\n      var p = layoutProgress.get() / progressTarget; // Tween the axis and update the visualElement with the latest values\n\n      tweenAxis(frameTarget, origin, target, p);\n      visualElement.setAxisTarget(axis, frameTarget.min, frameTarget.max); // If this is a crossfade animation, update both elements.\n\n      crossfade === null || crossfade === void 0 ? void 0 : crossfade(p);\n    }; // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\n\n\n    frame(); // Start the animation on this axis\n\n    var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, transition || this.props.transition || defaultTransition); // Create a function to stop animation on this specific axis\n\n    var unsubscribeProgress = layoutProgress.onChange(frame);\n\n    this.stopAxisAnimation[axis] = function () {\n      layoutProgress.stop();\n      unsubscribeProgress();\n    };\n\n    return animation;\n  };\n\n  Animate.prototype.createCrossfadeAnimation = function (crossfadeOpacity) {\n    var visualElement = this.props.visualElement;\n    var opacity = visualElement.getValue(\"opacity\", 0);\n    return function (p) {\n      opacity.set(easeCrossfadeIn(mix(0, 1, p)));\n      crossfadeOpacity.set(easeCrossfadeOut(mix(1, 0, p)));\n    };\n  };\n\n  Animate.prototype.safeToRemove = function () {\n    var _a, _b;\n\n    (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\n  };\n\n  Animate.prototype.render = function () {\n    return null;\n  };\n\n  return Animate;\n}(Component);\n\nvar AnimateLayout = {\n  key: \"animate-layout\",\n  shouldRender: function shouldRender(props) {\n    return !!props.layout || !!props.layoutId;\n  },\n  Component: function Component(props) {\n    var _a = usePresence(),\n        safeToRemove = _a[1];\n\n    return createElement(Animate, __assign({}, props, {\n      safeToRemove: safeToRemove\n    }));\n  }\n};\n\nfunction hasMoved(a, b) {\n  return hasAxisMoved(a.x, b.x) || hasAxisMoved(a.y, b.y);\n}\n\nfunction hasAxisMoved(a, b) {\n  return a.min !== b.min || a.max !== b.max;\n}\n\nvar defaultTransition = {\n  duration: 0.45,\n  ease: [0.4, 0, 0.1, 1]\n};\n\nfunction compress(min, max, easing) {\n  return function (p) {\n    // Could replace ifs with clamp\n    if (p < min) return 0;\n    if (p > max) return 1;\n    return easing(progress(min, max, p));\n  };\n}\n\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear$1);\n/**\n * Default handlers for batching VisualElements\n */\n\nvar defaultHandler = {\n  measureLayout: function measureLayout(child) {\n    return child.measureLayout();\n  },\n  layoutReady: function layoutReady(child) {\n    return child.layoutReady();\n  }\n};\n/**\n * Sort VisualElements by tree depth, so we process the highest elements first.\n */\n\nvar sortByDepth = function sortByDepth(a, b) {\n  return a.depth - b.depth;\n};\n/**\n * Create a batcher to process VisualElements\n */\n\n\nfunction createBatcher() {\n  var queue = new Set();\n\n  var add = function add(child) {\n    return queue.add(child);\n  };\n\n  var flush = function flush(_a) {\n    var _b = _a === void 0 ? defaultHandler : _a,\n        measureLayout = _b.measureLayout,\n        layoutReady = _b.layoutReady;\n\n    var order = Array.from(queue).sort(sortByDepth);\n    /**\n     * Write: Reset any transforms on children elements so we can read their actual layout\n     */\n\n    order.forEach(function (child) {\n      return child.resetTransform();\n    });\n    /**\n     * Read: Measure the actual layout\n     */\n\n    order.forEach(measureLayout);\n    /**\n     * Write: Notify the VisualElements they're ready for further write operations.\n     */\n\n    order.forEach(layoutReady);\n    /**\n     * After all children have started animating, ensure any Entering components are set to Present.\n     * If we add deferred animations (set up all animations and then start them in two loops) this\n     * could be moved to the start loop. But it needs to happen after all the animations configs\n     * are generated in AnimateSharedLayout as this relies on presence data\n     */\n\n    order.forEach(function (child) {\n      if (child.isPresent) child.presence = Presence.Present;\n    });\n    queue.clear();\n  };\n\n  return {\n    add: add,\n    flush: flush\n  };\n}\n\nfunction isSharedLayout(context) {\n  return !!context.forceUpdate;\n}\n\nvar SharedLayoutContext = createContext(createBatcher());\n/**\n * This component is responsible for scheduling the measuring of the motion component\n */\n\nvar Measure =\n/** @class */\nfunction (_super) {\n  __extends(Measure, _super);\n\n  function Measure(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * If this component isn't the child of a SyncContext, make it responsible for flushing\n     * the layout batcher\n     */\n\n\n    var syncLayout = props.syncLayout;\n\n    if (!isSharedLayout(syncLayout)) {\n      _this.componentDidUpdate = function () {\n        return syncLayout.flush();\n      };\n    }\n\n    return _this;\n  }\n  /**\n   * If this is a child of a SyncContext, register the VisualElement with it on mount.\n   */\n\n\n  Measure.prototype.componentDidMount = function () {\n    var _a = this.props,\n        syncLayout = _a.syncLayout,\n        visualElement = _a.visualElement;\n    isSharedLayout(syncLayout) && syncLayout.register(visualElement);\n  };\n  /**\n   * If this is a child of a SyncContext, notify it that it needs to re-render. It will then\n   * handle the snapshotting.\n   *\n   * If it is stand-alone component, add it to the batcher.\n   */\n\n\n  Measure.prototype.getSnapshotBeforeUpdate = function () {\n    var _a = this.props,\n        syncLayout = _a.syncLayout,\n        visualElement = _a.visualElement;\n\n    if (isSharedLayout(syncLayout)) {\n      syncLayout.syncUpdate();\n    } else {\n      visualElement.snapshotBoundingBox();\n      syncLayout.add(visualElement);\n    }\n\n    return null;\n  };\n\n  Measure.prototype.componentDidUpdate = function () {};\n\n  Measure.prototype.render = function () {\n    return null;\n  };\n\n  return Measure;\n}(React__default.Component);\n\nvar MeasureLayout = {\n  key: \"measure-layout\",\n  shouldRender: function shouldRender(props) {\n    return !!props.drag || !!props.layout || !!props.layoutId;\n  },\n  Component: function Component(props) {\n    var syncLayout = useContext(SharedLayoutContext);\n    return React__default.createElement(Measure, __assign({}, props, {\n      syncLayout: syncLayout\n    }));\n  }\n};\n/**\n * Currently we load all features synchronously, but it would be better to offer multiple entry points\n * that allow these to be loaded in asynchronously.\n */\n\nvar defaultFeatures = [MeasureLayout, Drag, Gestures, Exit, AnimateLayout];\n/**\n * Load features via renderless components based on the provided MotionProps\n */\n\nfunction useFeatures(isStatic, visualElement, controls, props, context, parentContext, shouldInheritVariant) {\n  var plugins = useContext(MotionPluginContext); // If this is a static component, or we're rendering on the server, we don't load\n  // any feature components\n\n  if (isStatic || typeof window === \"undefined\") return null;\n\n  var allFeatures = __spreadArrays(defaultFeatures, plugins.features);\n\n  var numFeatures = allFeatures.length;\n  var features = []; // TODO: Consolidate Animation feature loading strategy with other functionality components\n\n  var Animation = getAnimationComponent(props);\n\n  if (Animation) {\n    features.push(createElement(Animation, {\n      key: \"animation\",\n      initial: props.initial,\n      animate: props.animate,\n      variants: props.variants,\n      transition: props.transition,\n      controls: controls,\n      inherit: shouldInheritVariant,\n      visualElement: visualElement\n    }));\n  } // Decide which features we should render and add them to the returned array\n\n\n  for (var i = 0; i < numFeatures; i++) {\n    var _a = allFeatures[i],\n        shouldRender = _a.shouldRender,\n        key = _a.key,\n        Component = _a.Component;\n\n    if (shouldRender(props, parentContext)) {\n      features.push(createElement(Component, __assign({\n        key: key\n      }, props, {\n        localContext: context,\n        parentContext: parentContext,\n        visualElement: visualElement,\n        controls: controls\n      })));\n    }\n  }\n\n  return features;\n}\n\nfunction useSnapshotOnUnmount(visualElement) {\n  var syncLayout = useContext(SharedLayoutContext);\n  useUnmountEffect(function () {\n    if (isSharedLayout(syncLayout)) syncLayout.remove(visualElement);\n  });\n}\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n *\n * @internal\n */\n\n\nfunction createMotionComponent(Component, _a) {\n  var useVisualElement = _a.useVisualElement,\n      render = _a.render,\n      animationControlsConfig = _a.animationControlsConfig;\n\n  function MotionComponent(props, externalRef) {\n    var parentContext = useContext(MotionContext);\n    var shouldInheritVariant = checkShouldInheritVariant(props);\n    /**\n     * If a component isStatic, we only visually update it as a\n     * result of a React re-render, rather than any interactions or animations.\n     * If this component or any ancestor isStatic, we disable hardware acceleration\n     * and don't load any additional functionality.\n     */\n\n    var isStatic = parentContext.static || props.static || false;\n    /**\n     * Create a VisualElement for this component. A VisualElement provides a common\n     * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n     * providing a way of rendering to these APIs outside of the React render loop\n     * for more performant animations and interactions\n     */\n\n    var visualElement = useVisualElement(Component, props, parentContext.visualElement, isStatic, externalRef);\n    /**\n     * Scrape MotionValues from props and add/remove them to/from\n     * the VisualElement as necessary.\n     */\n\n    useMotionValues(visualElement, props);\n    /**\n     * Create animation controls for the VisualElement. It might be\n     * interesting to try and combine this with VisualElement itself in a further refactor.\n     */\n\n    var controls = useVisualElementAnimation(visualElement, props, animationControlsConfig);\n    /**\n     * Build the MotionContext to pass on to the next `motion` component.\n     */\n\n    var context = useMotionContext(parentContext, controls, visualElement, isStatic, props);\n    /**\n     * Load features as renderless components unless the component isStatic\n     */\n\n    var features = useFeatures(isStatic, visualElement, controls, props, context, parentContext, shouldInheritVariant);\n    var component = render(Component, props, visualElement);\n    /**\n     *\n     */\n\n    useSnapshotOnUnmount(visualElement); // The mount order and hierarchy is specific to ensure our element ref is hydrated by the time\n    // all plugins and features has to execute.\n\n    return createElement(Fragment, null, createElement(MotionContext.Provider, {\n      value: context\n    }, component), features);\n  }\n\n  return forwardRef(MotionComponent);\n}\n/**\n * DOM-specific config for `motion` components\n */\n\n\nvar config = {\n  useVisualElement: useDomVisualElement,\n  render: render,\n  animationControlsConfig: {\n    makeTargetAnimatable: parseDomVariant\n  }\n};\n/**\n * Convert any React component into a `motion` component. The provided component\n * **must** use `React.forwardRef` to the underlying DOM component you want to animate.\n *\n * ```jsx\n * const Component = React.forwardRef((props, ref) => {\n *   return <div ref={ref} />\n * })\n *\n * const MotionComponent = motion.custom(Component)\n * ```\n *\n * @public\n */\n\nfunction custom(Component) {\n  return createMotionComponent(Component, config);\n}\n\nvar componentCache = new Map();\n\nfunction get(target, key) {\n  if (key === \"custom\") return target.custom;\n\n  if (!componentCache.has(key)) {\n    componentCache.set(key, createMotionComponent(key, config));\n  }\n\n  return componentCache.get(key);\n}\n/**\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\n *\n * @public\n */\n\n\nvar motion = new Proxy({\n  custom: custom\n}, {\n  get: get\n});\n\nfunction useForceUpdate() {\n  var _a = useState(0),\n      forcedRenderCount = _a[0],\n      setForcedRenderCount = _a[1];\n\n  return useCallback(function () {\n    return setForcedRenderCount(forcedRenderCount + 1);\n  }, [forcedRenderCount]);\n}\n\nvar presenceId = 0;\n\nfunction getPresenceId() {\n  var id = presenceId;\n  presenceId++;\n  return id;\n}\n\nvar PresenceChild = function PresenceChild(_a) {\n  var children = _a.children,\n      initial = _a.initial,\n      isPresent = _a.isPresent,\n      _onExitComplete = _a.onExitComplete,\n      custom = _a.custom;\n  var presenceChildren = useConstant(newChildrenMap);\n  var context = {\n    id: useConstant(getPresenceId),\n    initial: initial,\n    isPresent: isPresent,\n    custom: custom,\n    onExitComplete: function onExitComplete(childId) {\n      presenceChildren.set(childId, true);\n      var allComplete = true;\n      presenceChildren.forEach(function (isComplete) {\n        if (!isComplete) allComplete = false;\n      });\n      allComplete && (_onExitComplete === null || _onExitComplete === void 0 ? void 0 : _onExitComplete());\n    },\n    register: function register(childId) {\n      presenceChildren.set(childId, false);\n      return function () {\n        return presenceChildren.delete(childId);\n      };\n    }\n  };\n  useMemo(function () {\n    presenceChildren.forEach(function (_, key) {\n      return presenceChildren.set(key, false);\n    });\n  }, [isPresent]);\n  return createElement(PresenceContext.Provider, {\n    value: context\n  }, children);\n};\n\nfunction newChildrenMap() {\n  return new Map();\n}\n\nfunction getChildKey(child) {\n  return child.key || \"\";\n}\n\nfunction updateChildLookup(children, allChildren) {\n  var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\n  children.forEach(function (child) {\n    var key = getChildKey(child);\n\n    if (process.env.NODE_ENV !== \"production\" && seenChildren) {\n      if (seenChildren.has(key)) {\n        console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\n      }\n\n      seenChildren.add(key);\n    }\n\n    allChildren.set(key, child);\n  });\n}\n\nfunction onlyElements(children) {\n  var filtered = []; // We use forEach here instead of map as map mutates the component key by preprending `.$`\n\n  Children.forEach(children, function (child) {\n    if (isValidElement(child)) filtered.push(child);\n  });\n  return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * @library\n *\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { Frame, AnimatePresence } from 'framer'\n *\n * // As items are added and removed from `items`\n * export function Items({ items }) {\n *   return (\n *     <AnimatePresence>\n *       {items.map(item => (\n *         <Frame\n *           key={item.id}\n *           initial={{ opacity: 0 }}\n *           animate={{ opacity: 1 }}\n *           exit={{ opacity: 0 }}\n *         />\n *       ))}\n *     </AnimatePresence>\n *   )\n * }\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * @motion\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\n\n\nvar AnimatePresence = function AnimatePresence(_a) {\n  var children = _a.children,\n      custom = _a.custom,\n      _b = _a.initial,\n      initial = _b === void 0 ? true : _b,\n      onExitComplete = _a.onExitComplete,\n      exitBeforeEnter = _a.exitBeforeEnter; // We want to force a re-render once all exiting animations have finished. We\n  // either use a local forceRender function, or one from a parent context if it exists.\n\n  var forceRender = useForceUpdate();\n  var layoutContext = useContext(SharedLayoutContext);\n\n  if (isSharedLayout(layoutContext)) {\n    forceRender = layoutContext.forceUpdate;\n  }\n\n  var isInitialRender = useRef(true); // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n\n  var filteredChildren = onlyElements(children); // Keep a living record of the children we're actually rendering so we\n  // can diff to figure out which are entering and exiting\n\n  var presentChildren = useRef(filteredChildren); // A lookup table to quickly reference components by key\n\n  var allChildren = useRef(new Map()).current; // A living record of all currently exiting components.\n\n  var exiting = useRef(new Set()).current;\n  updateChildLookup(filteredChildren, allChildren); // If this is the initial component render, just deal with logic surrounding whether\n  // we play onMount animations or not.\n\n  if (isInitialRender.current) {\n    isInitialRender.current = false;\n    return createElement(Fragment, null, filteredChildren.map(function (child) {\n      return createElement(PresenceChild, {\n        key: getChildKey(child),\n        isPresent: true,\n        initial: initial ? undefined : false\n      }, child);\n    }));\n  } // If this is a subsequent render, deal with entering and exiting children\n\n\n  var childrenToRender = __spreadArrays(filteredChildren); // Diff the keys of the currently-present and target children to update our\n  // exiting list.\n\n\n  var presentKeys = presentChildren.current.map(getChildKey);\n  var targetKeys = filteredChildren.map(getChildKey); // Diff the present children with our target children and mark those that are exiting\n\n  var numPresent = presentKeys.length;\n\n  for (var i = 0; i < numPresent; i++) {\n    var key = presentKeys[i];\n\n    if (targetKeys.indexOf(key) === -1) {\n      exiting.add(key);\n    } else {\n      // In case this key has re-entered, remove from the exiting list\n      exiting.delete(key);\n    }\n  } // If we currently have exiting children, and we're deferring rendering incoming children\n  // until after all current children have exiting, empty the childrenToRender array\n\n\n  if (exitBeforeEnter && exiting.size) {\n    childrenToRender = [];\n  } // Loop through all currently exiting components and clone them to overwrite `animate`\n  // with any `exit` prop they might have defined.\n\n\n  exiting.forEach(function (key) {\n    // If this component is actually entering again, early return\n    if (targetKeys.indexOf(key) !== -1) return;\n    var child = allChildren.get(key);\n    if (!child) return;\n    var insertionIndex = presentKeys.indexOf(key);\n\n    var onExit = function onExit() {\n      allChildren.delete(key);\n      exiting.delete(key); // Remove this child from the present children\n\n      var removeIndex = presentChildren.current.findIndex(function (presentChild) {\n        return presentChild.key === key;\n      });\n      presentChildren.current.splice(removeIndex, 1); // Defer re-rendering until all exiting children have indeed left\n\n      if (!exiting.size) {\n        presentChildren.current = filteredChildren;\n        forceRender();\n        onExitComplete && onExitComplete();\n      }\n    };\n\n    childrenToRender.splice(insertionIndex, 0, createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: false,\n      onExitComplete: onExit,\n      custom: custom\n    }, child));\n  }); // Add `MotionContext` even to children that don't need it to ensure we're rendering\n  // the same tree between renders\n\n  childrenToRender = childrenToRender.map(function (child) {\n    var key = child.key;\n    return exiting.has(key) ? child : createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: true\n    }, child);\n  });\n  presentChildren.current = childrenToRender;\n\n  if (process.env.NODE_ENV !== \"production\" && exitBeforeEnter && childrenToRender.length > 1) {\n    console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n  }\n\n  return createElement(Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function (child) {\n    return cloneElement(child);\n  }));\n};\n\nfunction createSwitchAnimation(child, stack) {\n  if (stack && child !== stack.lead) {\n    return {\n      visibilityAction: VisibilityAction.Hide\n    };\n  } else if (stack && child.presence !== Presence.Entering && child === stack.lead && stack.lead !== stack.prevLead) {\n    return {\n      visibilityAction: VisibilityAction.Show\n    };\n  }\n\n  var originBox;\n  var targetBox;\n\n  if (child.presence === Presence.Entering) {\n    originBox = stack === null || stack === void 0 ? void 0 : stack.getFollowOrigin();\n  } else if (child.presence === Presence.Exiting) {\n    targetBox = stack === null || stack === void 0 ? void 0 : stack.getFollowTarget();\n  }\n\n  return {\n    originBox: originBox,\n    targetBox: targetBox\n  };\n}\n\nfunction createCrossfadeAnimation(child, stack) {\n  var _a, _b, _c;\n\n  var config = {};\n  var stackLead = stack && stack.lead;\n  var stackLeadPresence = stackLead === null || stackLead === void 0 ? void 0 : stackLead.presence;\n\n  if (stack && child === stackLead) {\n    if (child.presence === Presence.Entering) {\n      config.originBox = stack.getFollowOrigin();\n    } else if (child.presence === Presence.Exiting) {\n      config.targetBox = stack.getFollowTarget();\n    }\n  } else if (stack && child === stack.follow) {\n    config.transition = stack.getLeadTransition();\n\n    if (stackLeadPresence === Presence.Entering) {\n      config.targetBox = stack.getLeadTarget();\n    } else if (stackLeadPresence === Presence.Exiting) {\n      config.originBox = stack.getLeadOrigin();\n    }\n  } // If neither the lead or follow component is the root child of AnimatePresence,\n  // don't handle crossfade animations\n\n\n  if (!((_a = stack === null || stack === void 0 ? void 0 : stack.follow) === null || _a === void 0 ? void 0 : _a.isPresenceRoot) && !(stackLead === null || stackLead === void 0 ? void 0 : stackLead.isPresenceRoot)) {\n    return config;\n  }\n\n  if (!stack || child === stackLead) {\n    if (child.presence === Presence.Entering) {\n      config.crossfadeOpacity = (_b = stack === null || stack === void 0 ? void 0 : stack.follow) === null || _b === void 0 ? void 0 : _b.getValue(\"opacity\", 0);\n    }\n  } else if (stack && child === stack.follow) {\n    if (!stackLead || stackLeadPresence === Presence.Entering) ;else if (stackLeadPresence === Presence.Exiting) {\n      config.crossfadeOpacity = (_c = stack === null || stack === void 0 ? void 0 : stack.lead) === null || _c === void 0 ? void 0 : _c.getValue(\"opacity\", 1);\n    }\n  } else {\n    config.visibilityAction = VisibilityAction.Hide;\n  }\n\n  return config;\n}\n/**\n * For each layout animation, we want to identify two components\n * within a stack that will serve as the \"lead\" and \"follow\" components.\n *\n * In the switch animation, the lead component performs the entire animation.\n * It uses the follow bounding box to animate out from and back to. The follow\n * component is hidden.\n *\n * In the crossfade animation, both the lead and follow components perform\n * the entire animation, animating from the follow origin bounding box to the lead\n * target bounding box.\n *\n * Generalising a stack as First In Last Out, *searching from the end* we can\n * generally consider the lead component to be:\n *  - If the last child is present, the last child\n *  - If the last child is exiting, the last *encountered* exiting component\n */\n\n\nfunction findLeadAndFollow(stack, _a) {\n  var prevLead = _a[0],\n      prevFollow = _a[1];\n  var lead = undefined;\n  var leadIndex = 0;\n  var follow = undefined; // Find the lead child first\n\n  var numInStack = stack.length;\n  var lastIsPresent = false;\n\n  for (var i = numInStack - 1; i >= 0; i--) {\n    var child = stack[i];\n    var isLastInStack = i === numInStack - 1;\n    if (isLastInStack) lastIsPresent = child.isPresent;\n\n    if (lastIsPresent) {\n      lead = child;\n    } else {\n      // If the child before this will be present, make this the\n      // lead.\n      var prev = stack[i - 1];\n      if (prev && prev.isPresent) lead = child;\n    }\n\n    if (lead) {\n      leadIndex = i;\n      break;\n    }\n  }\n\n  if (!lead) lead = stack[0]; // Find the follow child\n\n  follow = stack[leadIndex - 1]; // If the lead component is exiting, find the closest follow\n  // present component\n\n  if (lead) {\n    for (var i = leadIndex - 1; i >= 0; i--) {\n      var child = stack[i];\n\n      if (child.isPresent) {\n        follow = child;\n        break;\n      }\n    }\n  } // If the lead has changed and the previous lead still exists in the\n  // stack, set it to the previous lead. This allows us to differentiate between\n  // a, b, c(exit) -> a, b(exit), c(exit)\n  // and\n  // a, b(exit), c -> a, b(exit), c(exit)\n\n\n  if (lead !== prevLead && !lastIsPresent && follow === prevFollow && stack.find(function (stackChild) {\n    return stackChild === prevLead;\n  })) {\n    lead = prevLead;\n  }\n\n  return [lead, follow];\n}\n\nvar LayoutStack =\n/** @class */\nfunction () {\n  function LayoutStack() {\n    this.order = []; // Track whether we've ever had a child\n\n    this.hasChildren = false;\n  }\n\n  LayoutStack.prototype.add = function (child) {\n    var _a;\n\n    var layoutOrder = child.config.layoutOrder;\n\n    if (layoutOrder === undefined) {\n      this.order.push(child);\n    } else {\n      var index = this.order.findIndex(function (stackChild) {\n        return layoutOrder <= (stackChild.config.layoutOrder || 0);\n      });\n\n      if (index === -1) {\n        child.presence = this.hasChildren ? Presence.Entering : Presence.Present;\n        index = this.order.length;\n      }\n\n      this.order.splice(index, 0, child);\n    }\n    /**\n     *\n     */\n    // Load previous values from snapshot into this child\n    // TODO Neaten up\n    // TODO Double check when reimplementing move\n    // TODO Add isDragging status and\n\n\n    if (this.snapshot) {\n      child.prevSnapshot = this.snapshot; // TODO Remove in favour of above\n\n      child.prevViewportBox = this.snapshot.boundingBox;\n      var latest = this.snapshot.latestMotionValues;\n\n      for (var key in latest) {\n        if (!child.hasValue(key)) {\n          child.addValue(key, motionValue(latest[key]));\n        } else {\n          (_a = child.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(latest[key]);\n        }\n      }\n    }\n\n    this.hasChildren = true;\n  };\n\n  LayoutStack.prototype.remove = function (child) {\n    var index = this.order.findIndex(function (stackChild) {\n      return child === stackChild;\n    });\n    if (index !== -1) this.order.splice(index, 1);\n  };\n\n  LayoutStack.prototype.updateLeadAndFollow = function () {\n    this.prevLead = this.lead;\n    this.prevFollow = this.follow;\n\n    var _a = findLeadAndFollow(this.order, [this.lead, this.follow]),\n        lead = _a[0],\n        follow = _a[1];\n\n    this.lead = lead;\n    this.follow = follow;\n  };\n\n  LayoutStack.prototype.updateSnapshot = function () {\n    if (!this.lead) return;\n    var snapshot = {\n      boundingBox: this.lead.prevViewportBox,\n      latestMotionValues: {}\n    };\n    this.lead.forEachValue(function (value, key) {\n      var latest = value.get();\n\n      if (!isTransformProp(latest)) {\n        snapshot.latestMotionValues[key] = latest;\n      }\n    });\n    var dragControls = elementDragControls.get(this.lead);\n\n    if (dragControls && dragControls.isDragging) {\n      snapshot.isDragging = true;\n      snapshot.cursorProgress = dragControls.cursorProgress;\n    }\n\n    this.snapshot = snapshot;\n  };\n\n  LayoutStack.prototype.isLeadPresent = function () {\n    var _a;\n\n    return this.lead && ((_a = this.lead) === null || _a === void 0 ? void 0 : _a.presence) !== Presence.Exiting;\n  };\n\n  LayoutStack.prototype.shouldStackAnimate = function () {\n    return true; // return this.lead && this.lead?.isPresent\n    //     ? this.lead?.props?._shouldAnimate === true\n    //     : this.follow && this.follow?.props._shouldAnimate === true\n  };\n\n  LayoutStack.prototype.getFollowOrigin = function () {\n    var _a; // This shouldAnimate check is quite specifically a fix for the optimisation made in Framer\n    // where components are kept in the tree ready to be re-used\n\n\n    return this.follow // && this.follow.shouldAnimate\n    ? this.follow.prevViewportBox : (_a = this.snapshot) === null || _a === void 0 ? void 0 : _a.boundingBox;\n  };\n\n  LayoutStack.prototype.getFollowTarget = function () {\n    var _a;\n\n    return (_a = this.follow) === null || _a === void 0 ? void 0 : _a.box;\n  };\n\n  LayoutStack.prototype.getLeadOrigin = function () {\n    var _a;\n\n    return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.prevViewportBox;\n  };\n\n  LayoutStack.prototype.getLeadTarget = function () {\n    var _a;\n\n    return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.box;\n  };\n\n  LayoutStack.prototype.getLeadTransition = function () {\n    var _a;\n\n    return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.config.transition;\n  };\n\n  return LayoutStack;\n}();\n/**\n * @public\n */\n\n\nvar AnimateSharedLayout =\n/** @class */\nfunction (_super) {\n  __extends(AnimateSharedLayout, _super);\n\n  function AnimateSharedLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * A list of all the children in the shared layout\n     */\n\n\n    _this.children = new Set();\n    /**\n     * As animate components with a defined `layoutId` are added/removed to the tree,\n     * we store them in order. When one is added, it will animate out from the\n     * previous one, and when it's removed, it'll animate to the previous one.\n     */\n\n    _this.stacks = new Map();\n    /**\n     * Track whether the component has mounted. If it hasn't, the presence of added children\n     * are set to Present, whereas if it has they're considered Entering\n     */\n\n    _this.hasMounted = false;\n    /**\n     * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n     * and schedule one.\n     */\n\n    _this.updateScheduled = false;\n    /**\n     * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n     */\n\n    _this.renderScheduled = false;\n    /**\n     * The methods provided to all children in the shared layout tree.\n     */\n\n    _this.syncContext = __assign(__assign({}, createBatcher()), {\n      syncUpdate: function syncUpdate(force) {\n        return _this.scheduleUpdate(force);\n      },\n      forceUpdate: function forceUpdate() {\n        // By copying syncContext to itself, when this component re-renders it'll also re-render\n        // all children subscribed to the SharedLayout context.\n        _this.syncContext = __assign({}, _this.syncContext);\n\n        _this.scheduleUpdate(true);\n      },\n      register: function register(child) {\n        return _this.addChild(child);\n      },\n      remove: function remove(child) {\n        return _this.removeChild(child);\n      }\n    });\n    return _this;\n  }\n\n  AnimateSharedLayout.prototype.componentDidMount = function () {\n    this.hasMounted = true;\n    this.updateStacks();\n  };\n\n  AnimateSharedLayout.prototype.componentDidUpdate = function () {\n    this.startLayoutAnimation();\n  };\n\n  AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n    this.renderScheduled = true;\n    return true;\n  };\n\n  AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n    var _this = this;\n    /**\n     * Reset update and render scheduled status\n     */\n\n\n    this.renderScheduled = this.updateScheduled = false;\n    var type = this.props.type;\n    /**\n     * Update presence metadata based on the latest AnimatePresence status.\n     * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n     */\n\n    this.children.forEach(function (child) {\n      if (!child.isPresent) {\n        child.presence = Presence.Exiting;\n      } else if (child.presence !== Presence.Entering) {\n        child.presence = child.presence === Presence.Exiting ? Presence.Entering : Presence.Present;\n      }\n    });\n    /**\n     * In every layoutId stack, nominate a component to lead the animation and another\n     * to follow\n     */\n\n    this.updateStacks();\n    /**\n     * Decide which animation to use between shared layoutId components\n     */\n\n    var createAnimation = type === \"crossfade\" ? createCrossfadeAnimation : createSwitchAnimation;\n    /**\n     * Create a handler which we can use to flush the children animations\n     */\n\n    var handler = {\n      measureLayout: function measureLayout(child) {\n        return child.measureLayout();\n      },\n      layoutReady: function layoutReady(child) {\n        var layoutId = child.layoutId;\n        child.layoutReady(createAnimation(child, _this.getStack(layoutId)));\n      }\n    };\n    /**\n     * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n     * This requires some co-ordination across components to stop layout thrashing\n     * and ensure measurements are taken at the correct time.\n     *\n     * Here we use that same mechanism of schedule/flush.\n     */\n\n    this.children.forEach(function (child) {\n      return _this.syncContext.add(child);\n    });\n    this.syncContext.flush(handler);\n    /**\n     * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.snapshot = undefined;\n    });\n  };\n\n  AnimateSharedLayout.prototype.updateStacks = function () {\n    this.stacks.forEach(function (stack) {\n      return stack.updateLeadAndFollow();\n    });\n  };\n\n  AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (!(force || !this.updateScheduled)) return;\n    /**\n     * Flag we've scheduled an update\n     */\n\n    this.updateScheduled = true;\n    /**\n     * Snapshot children\n     */\n\n    this.children.forEach(function (child) {\n      return child.snapshotBoundingBox();\n    });\n    /**\n     * Every child keeps a local snapshot, but we also want to record\n     * snapshots of the visible children as, if they're are being removed\n     * in this render, we can still access them.\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.updateSnapshot();\n    });\n    /**\n     * Force a rerender by setting state if we aren't already going to render.\n     */\n\n    if (force || !this.renderScheduled) {\n      this.renderScheduled = true;\n      this.forceUpdate();\n    }\n  };\n\n  AnimateSharedLayout.prototype.addChild = function (child) {\n    this.children.add(child);\n    this.addToStack(child);\n    child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n  };\n\n  AnimateSharedLayout.prototype.removeChild = function (child) {\n    this.scheduleUpdate();\n    this.children.delete(child);\n    this.removeFromStack(child);\n  };\n\n  AnimateSharedLayout.prototype.addToStack = function (child) {\n    var stack = this.getStack(child.layoutId);\n    stack === null || stack === void 0 ? void 0 : stack.add(child);\n  };\n\n  AnimateSharedLayout.prototype.removeFromStack = function (child) {\n    var stack = this.getStack(child.layoutId);\n    stack === null || stack === void 0 ? void 0 : stack.remove(child);\n  };\n  /**\n   * Return a stack of animate children based on the provided layoutId.\n   * Will create a stack if none currently exists with that layoutId.\n   */\n\n\n  AnimateSharedLayout.prototype.getStack = function (id) {\n    if (id === undefined) return; // Create stack if it doesn't already exist\n\n    !this.stacks.has(id) && this.stacks.set(id, new LayoutStack());\n    return this.stacks.get(id);\n  };\n\n  AnimateSharedLayout.prototype.render = function () {\n    return createElement(SharedLayoutContext.Provider, {\n      value: this.syncContext\n    }, this.props.children);\n  };\n\n  return AnimateSharedLayout;\n}(Component);\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * @library\n *\n * ```jsx\n * export function MyComponent() {\n *   const scale = useMotionValue(1)\n *\n *   return <Frame scale={scale} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\n\n\nfunction useMotionValue(initial) {\n  return useConstant(function () {\n    return motionValue(initial);\n  });\n}\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n *\n * @internal\n */\n\n\nfunction resolveMotionValue(value) {\n  var unwrappedValue = value instanceof MotionValue ? value.get() : value;\n  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;\n}\n\nvar isCustomValueType = function isCustomValueType(v) {\n  return typeof v === \"object\" && v.mix;\n};\n\nvar getMixer = function getMixer(v) {\n  return isCustomValueType(v) ? v.mix : undefined;\n};\n\nfunction transform() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  var useImmediate = !Array.isArray(args[0]);\n  var argOffset = useImmediate ? 0 : -1;\n  var inputValue = args[0 + argOffset];\n  var inputRange = args[1 + argOffset];\n  var outputRange = args[2 + argOffset];\n  var options = args[3 + argOffset];\n  var interpolator = interpolate(inputRange, outputRange, __assign({\n    mixer: getMixer(outputRange[0])\n  }, options));\n  return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\nvar isTransformer = function isTransformer(v) {\n  return typeof v === \"function\";\n};\n\nfunction useTransform(parent, customTransform, to, options) {\n  var comparitor = isTransformer(customTransform) ? [parent] : [parent, customTransform.join(\",\"), to === null || to === void 0 ? void 0 : to.join(\",\")];\n  var transformer = useMemo(function () {\n    return isTransformer(customTransform) ? customTransform : transform(customTransform, to, options);\n  }, comparitor);\n  var initialValue = transformer(parent.get());\n  var value = useMotionValue(initialValue); // Handle subscription to parent\n\n  var unsubscribe = useRef();\n  useMemo(function () {\n    unsubscribe.current && unsubscribe.current();\n    unsubscribe.current = parent.onChange(function (v) {\n      return value.set(transformer(v));\n    }); // Manually set with the latest parent value in case we've re-parented\n\n    value.set(initialValue);\n  }, [parent, value, transformer]);\n  useUnmountEffect(function () {\n    return unsubscribe.current && unsubscribe.current();\n  });\n  return value;\n} // Keep things reasonable and avoid scale: Infinity. In practise we might need\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\n// to simply hide content at unreasonable scales.\n\n\nvar maxScale = 100000;\n\nvar invertScale = function invertScale(scale) {\n  return scale > 0.001 ? 1 / scale : maxScale;\n};\n/**\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\n * of their respective parent scales.\n *\n * This is useful for undoing the distortion of content when scaling a parent component.\n *\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\n * of those instead.\n *\n * @motion\n *\n * ```jsx\n * const MyComponent = () => {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <motion.div style={{ scaleX, scaleY }} />\n * }\n * ```\n *\n * @library\n *\n * ```jsx\n * function MyComponent() {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <Frame scaleX={scaleX} scaleY={scaleY} />\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useInvertedScale(scale) {\n  var parentScaleX = useMotionValue(1);\n  var parentScaleY = useMotionValue(1);\n  var visualElement = useContext(MotionContext).visualElement;\n  invariant(!!(scale || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n\n  if (scale) {\n    parentScaleX = scale.scaleX || parentScaleX;\n    parentScaleY = scale.scaleY || parentScaleY;\n  } else if (visualElement) {\n    parentScaleX = visualElement.getValue(\"scaleX\", 1);\n    parentScaleY = visualElement.getValue(\"scaleY\", 1);\n  }\n\n  var scaleX = useTransform(parentScaleX, invertScale);\n  var scaleY = useTransform(parentScaleY, invertScale);\n  return {\n    scaleX: scaleX,\n    scaleY: scaleY\n  };\n}\n\nfunction useOnChange(value, callback) {\n  useEffect(function () {\n    return isMotionValue(value) ? value.onChange(callback) : undefined;\n  }, [value]);\n}\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */\n\n\nfunction useSpring(source, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var activeSpringAnimation = useRef(null);\n  var value = useMotionValue(isMotionValue(source) ? source.get() : source);\n  useMemo(function () {\n    return value.attach(function (v, set) {\n      if (activeSpringAnimation.current) {\n        activeSpringAnimation.current.stop();\n      }\n\n      activeSpringAnimation.current = spring(__assign({\n        from: value.get(),\n        to: v,\n        velocity: value.getVelocity()\n      }, config)).start(set);\n      return value.get();\n    });\n  }, Object.values(config));\n  useOnChange(source, function (v) {\n    return value.set(parseFloat(v));\n  });\n  return value;\n}\n\nfunction createScrollMotionValues() {\n  return {\n    scrollX: motionValue(0),\n    scrollY: motionValue(0),\n    scrollXProgress: motionValue(0),\n    scrollYProgress: motionValue(0)\n  };\n}\n\nfunction setProgress(offset, maxOffset, value) {\n  value.set(!offset || !maxOffset ? 0 : offset / maxOffset);\n}\n\nfunction createScrollUpdater(values, getOffsets) {\n  var update = function update() {\n    var _a = getOffsets(),\n        xOffset = _a.xOffset,\n        yOffset = _a.yOffset,\n        xMaxOffset = _a.xMaxOffset,\n        yMaxOffset = _a.yMaxOffset; // Set absolute positions\n\n\n    values.scrollX.set(xOffset);\n    values.scrollY.set(yOffset); // Set 0-1 progress\n\n    setProgress(xOffset, xMaxOffset, values.scrollXProgress);\n    setProgress(yOffset, yMaxOffset, values.scrollYProgress);\n  };\n\n  update();\n  return update;\n}\n\nvar isBrowser$2 = typeof window !== \"undefined\";\nvar useIsomorphicLayoutEffect = isBrowser$2 ? useLayoutEffect : useEffect;\n\nvar getElementScrollOffsets = function getElementScrollOffsets(element) {\n  return function () {\n    return {\n      xOffset: element.scrollLeft,\n      yOffset: element.scrollTop,\n      xMaxOffset: element.scrollWidth - element.offsetWidth,\n      yMaxOffset: element.scrollHeight - element.offsetHeight\n    };\n  };\n};\n/**\n * Returns MotionValues that update when the provided element scrolls:\n *\n * - `scrollX` — Horizontal scroll distance in pixels.\n * - `scrollY` — Vertical scroll distance in pixels.\n * - `scrollXProgress` — Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress` — Vertical scroll progress between `0` and `1`.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useElementScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const ref = React.useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <Frame ref={ref}>\n *       <Frame scaleX={scrollYProgress} />\n *     </Frame>\n *   )\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const ref = useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <div ref={ref}>\n *       <motion.div style={{ scaleX: scrollYProgress }} />\n *     </div>\n *   )\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useElementScroll(ref) {\n  var values = useConstant(createScrollMotionValues);\n  useIsomorphicLayoutEffect(function () {\n    var element = ref.current;\n    invariant(!!element, \"ref provided to useScroll must be passed into a HTML element.\");\n    if (!element) return;\n    var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));\n    var scrollListener = addDomEvent(element, \"scroll\", updateScrollValues, {\n      passive: true\n    });\n    var resizeListener = addDomEvent(element, \"resize\", updateScrollValues);\n    return function () {\n      scrollListener && scrollListener();\n      resizeListener && resizeListener();\n    };\n  }, []);\n  return values;\n}\n\nvar viewportScrollValues = createScrollMotionValues();\n\nfunction getViewportScrollOffsets() {\n  return {\n    xOffset: window.pageXOffset,\n    yOffset: window.pageYOffset,\n    xMaxOffset: document.body.clientWidth - window.innerWidth,\n    yMaxOffset: document.body.clientHeight - window.innerHeight\n  };\n}\n\nvar hasListeners = false;\n\nfunction addEventListeners() {\n  hasListeners = true;\n  if (typeof window === \"undefined\") return;\n  var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);\n  addDomEvent(window, \"scroll\", updateScrollValues, {\n    passive: true\n  });\n  addDomEvent(window, \"resize\", updateScrollValues);\n}\n/**\n * Returns MotionValues that update when the viewport scrolls:\n *\n * - `scrollX` — Horizontal scroll distance in pixels.\n * - `scrollY` — Vertical scroll distance in pixels.\n * - `scrollXProgress` — Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress` — Vertical scroll progress between `0` and `1`.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useViewportScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <Frame scaleX={scrollYProgress} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <motion.div style={{ scaleX: scrollYProgress }} />\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useViewportScroll() {\n  useIsomorphicLayoutEffect(function () {\n    !hasListeners && addEventListeners();\n  }, []);\n  return viewportScrollValues;\n}\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * @library\n *\n * ```jsx\n * import * as React from 'react'\n * import { Frame, useAnimation } from 'framer'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <Frame animate={controls} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\n\n\nfunction useAnimation() {\n  var animationControls = useConstant(function () {\n    return new AnimationControls();\n  });\n  useEffect(function () {\n    animationControls.mount();\n    return function () {\n      return animationControls.unmount();\n    };\n  }, []);\n  return animationControls;\n}\n/**\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import { Frame, useCycle } from \"framer\"\n *\n * export function MyComponent() {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <Frame\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @motion\n *\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { motion, useCycle } from \"framer-motion\"\n *\n * export const MyComponent = () => {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @param items - items to cycle through\n * @returns [currentState, cycleState]\n *\n * @public\n */\n\n\nfunction useCycle() {\n  var items = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    items[_i] = arguments[_i];\n  } // TODO: After Framer X beta, remove this warning\n\n\n  warning(items.length > 1, \"useCycle syntax has changed. `useCycle([0, 1, 2])` becomes `useCycle(0, 1, 2)`\");\n  var index = useRef(0);\n\n  var _a = useState(items[index.current]),\n      item = _a[0],\n      setItem = _a[1];\n\n  return [item, function (next) {\n    index.current = typeof next !== \"number\" ? wrap(0, items.length, index.current + 1) : next;\n    setItem(items[index.current]);\n  }];\n} // Does this device prefer reduced motion? Returns `null` server-side.\n\n\nvar prefersReducedMotion = motionValue(null);\n\nif (typeof window !== \"undefined\") {\n  if (window.matchMedia) {\n    var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\n\n    var setReducedMotionPreferences = function setReducedMotionPreferences() {\n      return prefersReducedMotion.set(motionMediaQuery_1.matches);\n    };\n\n    motionMediaQuery_1.addListener(setReducedMotionPreferences);\n    setReducedMotionPreferences();\n  } else {\n    prefersReducedMotion.set(false);\n  }\n}\n\nfunction determineShouldReduceMotion(prefersReduced, isReducedMotion) {\n  return typeof isReducedMotion === \"boolean\" ? isReducedMotion : Boolean(prefersReduced);\n}\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */\n\n\nfunction useReducedMotion() {\n  var isReducedMotion = useContext(MotionContext).isReducedMotion;\n\n  var _a = useState(determineShouldReduceMotion(prefersReducedMotion.get(), isReducedMotion)),\n      shouldReduceMotion = _a[0],\n      setShouldReduceMotion = _a[1];\n\n  useEffect(function () {\n    return prefersReducedMotion.onChange(function (v) {\n      setShouldReduceMotion(determineShouldReduceMotion(v, isReducedMotion));\n    });\n  }, [setShouldReduceMotion, isReducedMotion]);\n  return shouldReduceMotion;\n}\n/**\n * Define accessibility options for a tree. Can be used to force the tree into Reduced Motion mode,\n * or disable device detection.\n *\n * @internal\n */\n\n\nfunction ReducedMotion(_a) {\n  var children = _a.children,\n      enabled = _a.enabled;\n  var context = useContext(MotionContext);\n  context = useMemo(function () {\n    return __assign(__assign({}, context), {\n      isReducedMotion: enabled\n    });\n  }, [enabled]);\n  return createElement(MotionContext.Provider, {\n    value: context\n  }, children);\n}\n/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onMouseDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\n\n\nvar DragControls =\n/** @class */\nfunction () {\n  function DragControls() {\n    this.componentControls = new Set();\n  }\n  /**\n   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n   *\n   * @internal\n   */\n\n\n  DragControls.prototype.subscribe = function (controls) {\n    var _this = this;\n\n    this.componentControls.add(controls);\n    return function () {\n      return _this.componentControls.delete(controls);\n    };\n  };\n  /**\n   * Start a drag gesture on every `motion` component that has this set of drag controls\n   * passed into it via the `dragControls` prop.\n   *\n   * ```jsx\n   * dragControls.start(e, {\n   *   snapToCursor: true\n   * })\n   * ```\n   *\n   * @param event - A mouse/touch/pointer event.\n   * @param options - Options\n   *\n   * @public\n   */\n\n\n  DragControls.prototype.start = function (event, options) {\n    this.componentControls.forEach(function (controls) {\n      controls.start(event.nativeEvent || event, options);\n    });\n  };\n\n  return DragControls;\n}();\n\nvar createDragControls = function createDragControls() {\n  return new DragControls();\n};\n/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component's `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onMouseDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\n\n\nfunction useDragControls() {\n  return useConstant(createDragControls);\n}\n/**\n * Uses the ref that is passed in, or creates a new one\n * @param external - External ref\n * @internal\n */\n\n\nfunction useExternalRef(externalRef) {\n  // We're conditionally calling `useRef` here which is sort of naughty as hooks\n  // shouldn't be called conditionally. However, Framer Motion will break if this\n  // condition changes anyway. It might be possible to use an invariant here to\n  // make it explicit, but I expect changing `ref` is not normal behaviour.\n  var ref = !externalRef || typeof externalRef === \"function\" ? useRef(null) : externalRef; // Handle `ref` functions. Again, calling the hook conditionally is kind of naughty\n  // but `ref` types changing between renders would break Motion anyway. If we receive\n  // bug reports about this, we should track the provided ref and throw an invariant\n  // rather than move the conditional to inside the useEffect as this will be fired\n  // for every Frame component within Framer.\n\n  if (externalRef && typeof externalRef === \"function\") {\n    useEffect(function () {\n      externalRef(ref.current);\n      return function () {\n        return externalRef(null);\n      };\n    }, []);\n  }\n\n  return ref;\n}\n/**\n * This is just a very basic VisualElement, more of a hack to keep supporting useAnimatedState with\n * the latest APIs.\n */\n\n\nvar StateVisualElement =\n/** @class */\nfunction (_super) {\n  __extends(StateVisualElement, _super);\n\n  function StateVisualElement() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.initialState = {};\n    return _this;\n  }\n\n  StateVisualElement.prototype.build = function () {};\n\n  StateVisualElement.prototype.clean = function () {};\n\n  StateVisualElement.prototype.getBoundingBox = function () {\n    return {\n      x: {\n        min: 0,\n        max: 0\n      },\n      y: {\n        min: 0,\n        max: 0\n      }\n    };\n  };\n\n  StateVisualElement.prototype.readNativeValue = function (key) {\n    return this.initialState[key] || 0;\n  };\n\n  StateVisualElement.prototype.render = function () {\n    this.build();\n  };\n\n  return StateVisualElement;\n}(VisualElement);\n/**\n * This is not an officially supported API and may be removed\n * on any version.\n * @internal\n */\n\n\nfunction useAnimatedState(initialState) {\n  var _a = useState(initialState),\n      animationState = _a[0],\n      setAnimationState = _a[1];\n\n  var visualElement = useConstant(function () {\n    return new StateVisualElement();\n  });\n  visualElement.updateConfig({\n    onUpdate: function onUpdate(v) {\n      return setAnimationState(__assign({}, v));\n    }\n  });\n  visualElement.initialState = initialState;\n  var controls = useVisualElementAnimation(visualElement, {}, {});\n  useEffect(function () {\n    visualElement.mount({});\n    return function () {\n      return visualElement.unmount();\n    };\n  }, []);\n  var startAnimation = useConstant(function () {\n    return function (animationDefinition) {\n      return controls.start(animationDefinition);\n    };\n  });\n  return [animationState, startAnimation];\n}\n\nexport { AnimatePresence, AnimateSharedLayout, AnimationControls, DragControls, MotionContext, MotionPluginContext, MotionPlugins, MotionValue, PresenceContext, ReducedMotion, VisualElementAnimationControls, addScaleCorrection, animationControls, createMotionComponent, isValidMotionProp, motion, motionValue, resolveMotionValue, transform, useAnimatedState, useAnimation, useCycle, useDomEvent, useDragControls, useElementScroll, useExternalRef, useGestures, useInvertedScale, useIsPresent, useMotionValue, usePanGesture, usePresence, useReducedMotion, useSpring, useTapGesture, useTransform, useViewportScroll };"],"sourceRoot":""}